<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameTime - Your Ultimate Minigames Destination</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        'primary-dark': '#4845B8'
                    }
                }
            }
        }
    </script>
    <style>
        .game-canvas {
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            touch-action: none;
        }
        .dark .game-canvas {
            border-color: #374151;
        }
        .memory-card {
            perspective: 1000px;
        }
        .memory-card-inner {
            transition: transform 0.3s;
            transform-style: preserve-3d;
        }
        .memory-card.flipped .memory-card-inner {
            transform: rotateY(180deg);
        }
        .memory-card-front, .memory-card-back {
            backface-visibility: hidden;
        }
        .memory-card-back {
            transform: rotateY(180deg);
        }
        .pixel-cell {
            border: 1px solid #ddd;
            cursor: pointer;
            aspect-ratio: 1;
        }
        .color-swatch {
            width: 40px;
            height: 40px;
            border: 2px solid #333;
            cursor: pointer;
            border-radius: 8px;
        }
        .anagram-letter {
            display: inline-block;
            padding: 8px 12px;
            margin: 2px;
            background: #e5e7eb;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
        }
        .sudoku-cell {
            width: 40px;
            height: 40px;
            border: 1px solid #333;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
        }
        .sliding-tile {
            width: 60px;
            height: 60px;
            background: #5D5CDE;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
        }
        .quiz-option {
            padding: 12px 20px;
            background: #f3f4f6;
            border: 2px solid #d1d5db;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .quiz-option:hover {
            background: #e5e7eb;
        }
        .quiz-option.correct {
            background: #dcfce7;
            border-color: #16a34a;
        }
        .quiz-option.incorrect {
            background: #fef2f2;
            border-color: #dc2626;
        }
        .shape-btn {
            padding: 8px 16px;
            background: #5D5CDE;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 2px;
        }
        .shape-btn:hover {
            background: #4845B8;
        }
        .mobile-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: rgba(93, 92, 222, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 24px;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        @media (max-width: 768px) {
            .mobile-btn {
                display: flex;
            }
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-white transition-colors duration-300">
    <!-- Navigation -->
    <nav class="bg-primary dark:bg-primary-dark shadow-lg">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16">
                <div class="flex items-center">
                    <h1 class="text-2xl font-bold text-white cursor-pointer" onclick="showPage('home')">üéÆ GameTime</h1>
                </div>
                <div class="hidden md:flex items-center space-x-8">
                    <button onclick="showPage('home')" class="text-white hover:text-gray-200 transition-colors">Home</button>
                    <button onclick="showCategory('drawing')" class="text-white hover:text-gray-200 transition-colors">Drawing</button>
                    <button onclick="showCategory('puzzle')" class="text-white hover:text-gray-200 transition-colors">Puzzle</button>
                    <button onclick="showCategory('skill')" class="text-white hover:text-gray-200 transition-colors">Skill</button>
                    <button onclick="showCategory('arcade')" class="text-white hover:text-gray-200 transition-colors">Arcade</button>
                </div>
                <div class="md:hidden flex items-center">
                    <button onclick="toggleMobileMenu()" class="text-white">
                        <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
        <!-- Mobile menu -->
        <div id="mobile-menu" class="md:hidden hidden bg-primary-dark">
            <div class="px-2 pt-2 pb-3 space-y-1">
                <button onclick="showPage('home'); toggleMobileMenu()" class="block text-white hover:text-gray-200 px-3 py-2">Home</button>
                <button onclick="showCategory('drawing'); toggleMobileMenu()" class="block text-white hover:text-gray-200 px-3 py-2">Drawing</button>
                <button onclick="showCategory('puzzle'); toggleMobileMenu()" class="block text-white hover:text-gray-200 px-3 py-2">Puzzle</button>
                <button onclick="showCategory('skill'); toggleMobileMenu()" class="block text-white hover:text-gray-200 px-3 py-2">Skill</button>
                <button onclick="showCategory('arcade'); toggleMobileMenu()" class="block text-white hover:text-gray-200 px-3 py-2">Arcade</button>
            </div>
        </div>
    </nav>

    <!-- Mobile Action Button -->
    <button id="mobile-action-btn" class="mobile-btn" onclick="handleMobileAction()">‚ñ∂</button>
    
    <!-- Reset Button -->
    <button id="reset-btn" class="mobile-btn" onclick="resetCurrentGame()" style="bottom: 90px; display: none;">üîÑ</button>

    <!-- Main Content -->
    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <!-- Homepage -->
        <div id="home-page" class="page">
            <!-- Hero Banner -->
            <div class="bg-gradient-to-r from-primary to-primary-dark rounded-lg text-white p-8 mb-8">
                <div class="text-center">
                    <h2 class="text-4xl md:text-5xl font-bold mb-4">Welcome to GameTime!</h2>
                    <p class="text-xl mb-6">Discover amazing minigames and challenge yourself</p>
                    <div class="max-w-md mx-auto">
                        <input type="text" id="search-input" placeholder="Search for games..." 
                               class="w-full px-4 py-3 text-base text-gray-900 rounded-lg border-0 focus:ring-2 focus:ring-white focus:outline-none"
                               oninput="searchGames(this.value)">
                    </div>
                </div>
            </div>

            <!-- Featured Games -->
            <section class="mb-8">
                <h3 class="text-2xl font-bold mb-6">üåü Featured Games</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    <div class="game-card bg-gray-100 dark:bg-gray-800 rounded-lg p-6 cursor-pointer hover:shadow-lg transition-shadow" onclick="showGame('paint-canvas')">
                        <div class="text-4xl mb-3">üé®</div>
                        <h4 class="text-lg font-semibold mb-2">Paint Canvas</h4>
                        <p class="text-gray-600 dark:text-gray-400">Express your creativity with this digital painting tool!</p>
                    </div>
                    <div class="game-card bg-gray-100 dark:bg-gray-800 rounded-lg p-6 cursor-pointer hover:shadow-lg transition-shadow" onclick="showGame('snake-game')">
                        <div class="text-4xl mb-3">üêç</div>
                        <h4 class="text-lg font-semibold mb-2">Snake Game</h4>
                        <p class="text-gray-600 dark:text-gray-400">Classic snake game with touch controls!</p>
                    </div>
                    <div class="game-card bg-gray-100 dark:bg-gray-800 rounded-lg p-6 cursor-pointer hover:shadow-lg transition-shadow" onclick="showGame('game-2048')">
                        <div class="text-4xl mb-3">üî¢</div>
                        <h4 class="text-lg font-semibold mb-2">2048</h4>
                        <p class="text-gray-600 dark:text-gray-400">Swipe to combine tiles and reach 2048!</p>
                    </div>
                </div>
            </section>

            <!-- Categories -->
            <section>
                <h3 class="text-2xl font-bold mb-6">üéÆ Game Categories</h3>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <button onclick="showCategory('drawing')" class="category-card bg-blue-100 dark:bg-blue-900 rounded-lg p-6 text-center hover:shadow-lg transition-all">
                        <div class="text-3xl mb-2">üé®</div>
                        <h4 class="font-semibold">Drawing Games</h4>
                        <p class="text-sm text-gray-600 dark:text-gray-400">6 games</p>
                    </button>
                    <button onclick="showCategory('puzzle')" class="category-card bg-green-100 dark:bg-green-900 rounded-lg p-6 text-center hover:shadow-lg transition-all">
                        <div class="text-3xl mb-2">üß©</div>
                        <h4 class="font-semibold">Puzzle Games</h4>
                        <p class="text-sm text-gray-600 dark:text-gray-400">6 games</p>
                    </button>
                    <button onclick="showCategory('skill')" class="category-card bg-yellow-100 dark:bg-yellow-900 rounded-lg p-6 text-center hover:shadow-lg transition-all">
                        <div class="text-3xl mb-2">üéØ</div>
                        <h4 class="font-semibold">Skill Games</h4>
                        <p class="text-sm text-gray-600 dark:text-gray-400">6 games</p>
                    </button>
                    <button onclick="showCategory('arcade')" class="category-card bg-purple-100 dark:bg-purple-900 rounded-lg p-6 text-center hover:shadow-lg transition-all">
                        <div class="text-3xl mb-2">üïπÔ∏è</div>
                        <h4 class="font-semibold">Arcade Games</h4>
                        <p class="text-sm text-gray-600 dark:text-gray-400">6 games</p>
                    </button>
                </div>
            </section>
        </div>

        <!-- Category Pages -->
        <div id="category-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 id="category-title" class="text-3xl font-bold">Category</h2>
            </div>
            <div id="category-games" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <!-- Games will be populated here -->
            </div>
        </div>

        <!-- Paint Canvas -->
        <div id="paint-canvas-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">üé® Paint Canvas</h2>
            </div>
            
            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Choose colors and brush sizes to create your masterpiece! Touch and drag to paint on mobile.</p>
            </div>

            <div class="text-center">
                <div class="mb-4 flex flex-wrap justify-center gap-2">
                    <div class="color-swatch bg-black" onclick="setPaintColor('#000000')"></div>
                    <div class="color-swatch bg-red-500" onclick="setPaintColor('#EF4444')"></div>
                    <div class="color-swatch bg-blue-500" onclick="setPaintColor('#3B82F6')"></div>
                    <div class="color-swatch bg-green-500" onclick="setPaintColor('#10B981')"></div>
                    <div class="color-swatch bg-yellow-500" onclick="setPaintColor('#F59E0B')"></div>
                    <div class="color-swatch bg-purple-500" onclick="setPaintColor('#8B5CF6')"></div>
                    <button class="px-4 py-2 bg-gray-300 hover:bg-gray-400 text-gray-800 rounded-lg transition-colors" onclick="setEraser()">üßπ Eraser</button>
                </div>
                <div class="mb-4">
                    <label class="mr-2">Brush Size:</label>
                    <input type="range" id="brush-size" min="1" max="20" value="5" onchange="setBrushSize(this.value)">
                    <span id="brush-size-display" class="ml-2">5px</span>
                </div>
                <canvas id="paint-canvas" class="game-canvas mx-auto mb-4" width="600" height="400"></canvas>
                <div class="space-y-4">
                    <button onclick="clearPaintCanvas()" class="bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded-lg transition-colors mr-2">Clear</button>
                    <button onclick="downloadPainting()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">Download</button>
                </div>
            </div>
        </div>

        <!-- Snake Game -->
        <div id="snake-game-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">üêç Snake Game</h2>
            </div>

            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Use arrow keys or swipe on mobile to move the snake. Eat food to grow longer!</p>
            </div>

            <div class="text-center">
                <div class="mb-4">
                    <span class="text-lg font-semibold">Score: <span id="snake-score">0</span></span>
                </div>
                <canvas id="snake-canvas" class="game-canvas mx-auto mb-4" width="320" height="320"></canvas>
                <button id="snake-start-btn" onclick="startSnakeGame()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">Start Game</button>
            </div>
        </div>

        <!-- 2048 Game -->
        <div id="game-2048-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">üî¢ 2048</h2>
            </div>

            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Swipe or use arrow keys to move tiles. Merge tiles with the same number to reach 2048!</p>
            </div>

            <div class="text-center">
                <div class="mb-4">
                    <span class="text-lg font-semibold">Score: <span id="game-2048-score">0</span></span>
                </div>
                <div id="game-2048-container" class="inline-block relative">
                    <div id="game-2048-grid" class="bg-gray-400 p-2 rounded-lg mb-4">
                        <!-- Game grid will be generated here -->
                    </div>
                </div>
                <div id="game-2048-status" class="text-xl font-semibold mb-4"></div>
                <button onclick="restart2048()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">New Game</button>
            </div>
        </div>

        <!-- Memory Match Game -->
        <div id="memory-match-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">üß† Memory Match</h2>
            </div>

            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Click cards to flip them over and find matching pairs!</p>
            </div>

            <div class="text-center">
                <div class="mb-4">
                    <span class="text-lg font-semibold">Moves: <span id="move-counter">0</span></span>
                    <span class="ml-6 text-lg font-semibold">Matches: <span id="match-counter">0</span>/8</span>
                </div>
                <div id="memory-grid" class="grid grid-cols-4 gap-3 max-w-md mx-auto mb-4">
                    <!-- Cards will be generated here -->
                </div>
                <button onclick="resetMemoryGame()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">New Game</button>
            </div>
        </div>

        <!-- Reaction Time Game -->
        <div id="reaction-time-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">‚ö° Reaction Time Test</h2>
            </div>

            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Wait for green, then tap as quickly as possible!</p>
            </div>

            <div class="text-center">
                <div id="reaction-area" class="w-full max-w-md mx-auto h-64 bg-gray-300 dark:bg-gray-700 rounded-lg flex items-center justify-center mb-6 cursor-pointer transition-colors" onclick="handleReactionClick()">
                    <div id="reaction-text" class="text-xl font-semibold">Tap "Start" to begin</div>
                </div>
                <div class="space-y-4">
                    <button id="reaction-start-btn" onclick="startReactionTest()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">Start</button>
                    <div id="reaction-result" class="text-xl font-semibold"></div>
                </div>
            </div>
        </div>

        <!-- Click Accuracy -->
        <div id="click-accuracy-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">üéØ Click Accuracy</h2>
            </div>

            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Tap the targets as they appear. Try to hit as many as possible!</p>
            </div>

            <div class="text-center">
                <div class="mb-4 flex justify-center gap-8">
                    <span class="text-lg font-semibold">Score: <span id="accuracy-score">0</span></span>
                    <span class="text-lg font-semibold">Time: <span id="accuracy-time">30s</span></span>
                </div>
                <div id="accuracy-game-area" class="relative w-full max-w-md mx-auto h-64 bg-gray-200 dark:bg-gray-700 rounded-lg mb-4 overflow-hidden">
                    <!-- Targets will appear here -->
                </div>
                <button onclick="startAccuracyGame()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">Start Game</button>
            </div>
        </div>

        <!-- Pixel Art -->
        <div id="pixel-art-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">üü¶ Pixel Art</h2>
            </div>
            
            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Tap on grid cells to paint them. Choose different colors to make your pixel art!</p>
            </div>

            <div class="text-center">
                <div class="mb-4 flex flex-wrap justify-center gap-2">
                    <div class="color-swatch bg-black" onclick="setPixelColor('#000000')"></div>
                    <div class="color-swatch bg-red-500" onclick="setPixelColor('#EF4444')"></div>
                    <div class="color-swatch bg-blue-500" onclick="setPixelColor('#3B82F6')"></div>
                    <div class="color-swatch bg-green-500" onclick="setPixelColor('#10B981')"></div>
                    <div class="color-swatch bg-yellow-500" onclick="setPixelColor('#F59E0B')"></div>
                    <div class="color-swatch bg-white border-gray-400" onclick="setPixelColor('#FFFFFF')"></div>
                </div>
                <div class="flex justify-center mb-4">
                    <div id="pixel-grid" class="grid gap-0 bg-white border-2 border-gray-400 w-80 h-80 max-w-full">
                        <!-- Grid will be generated here -->
                    </div>
                </div>
                <button onclick="clearPixelArt()" class="bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded-lg transition-colors">Clear</button>
            </div>
        </div>

        <!-- Word Guess -->
        <div id="word-guess-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">üî§ Word Guess Challenge</h2>
            </div>

            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Guess the word in limited tries! Green = correct letter in correct position, Yellow = correct letter in wrong position, Gray = letter not in word.</p>
            </div>

            <div class="text-center">
                <!-- Category Selection -->
                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-3">Select Category:</h3>
                    <div class="mb-4">
                        <select id="word-category" class="px-4 py-3 text-base border rounded-lg">
                            <option value="general">General Words</option>
                            <option value="animals">Animals</option>
                            <option value="colors">Colors</option>
                            <option value="food">Food</option>
                            <option value="nature">Nature</option>
                            <option value="science">Science</option>
                            <option value="sports">Sports</option>
                        </select>
                    </div>
                </div>

                <div class="mb-4 flex flex-wrap justify-center gap-4">
                    <span class="text-lg font-semibold">Score: <span id="word-score">0</span></span>
                    <span class="text-lg font-semibold">Streak: <span id="word-streak">0</span></span>
                    <span class="text-lg font-semibold">Difficulty: <span id="current-word-difficulty">Medium</span></span>
                    <span class="text-lg font-semibold">Category: <span id="current-word-category">General</span></span>
                </div>
                
                <div id="word-grid" class="inline-block mb-6">
                    <!-- Word grid will be generated here -->
                </div>
                
                <div id="word-keyboard" class="max-w-lg mx-auto mb-6">
                    <!-- Virtual keyboard will be generated here -->
                </div>
                
                <div class="space-x-4">
                    <button onclick="newWordGame()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">New Word</button>
                    <button onclick="resetWordGuess()" class="bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded-lg transition-colors">Reset</button>
                    <button onclick="giveWordHint()" class="bg-yellow-500 hover:bg-yellow-600 text-white px-6 py-2 rounded-lg transition-colors">Hint (-5 pts)</button>
                </div>
                <div id="word-result" class="text-xl font-semibold mt-4"></div>
                <div id="word-hint" class="text-sm text-gray-600 dark:text-gray-400 mt-2"></div>
            </div>
        </div>

        <!-- Typing Speed -->
        <div id="typing-speed-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">‚å®Ô∏è Typing Challenge</h2>
            </div>

            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Choose your challenge and type as quickly and accurately as possible!</p>
            </div>

            <div class="text-center">
                <!-- Challenge Selection -->
                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-3">Select Challenge:</h3>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-3 max-w-4xl mx-auto mb-4">
                        <button onclick="setTypingChallenge('words')" class="typing-challenge-btn bg-blue-500 text-white px-4 py-3 rounded-lg hover:bg-blue-600 transition-colors">
                            üìù Common Words
                        </button>
                        <button onclick="setTypingChallenge('quotes')" class="typing-challenge-btn bg-green-500 text-white px-4 py-3 rounded-lg hover:bg-green-600 transition-colors">
                            üí≠ Famous Quotes
                        </button>
                        <button onclick="setTypingChallenge('code')" class="typing-challenge-btn bg-purple-500 text-white px-4 py-3 rounded-lg hover:bg-purple-600 transition-colors">
                            üíª Code Snippets
                        </button>
                        <button onclick="setTypingChallenge('numbers')" class="typing-challenge-btn bg-orange-500 text-white px-4 py-3 rounded-lg hover:bg-orange-600 transition-colors">
                            üî¢ Numbers
                        </button>
                        <button onclick="setTypingChallenge('punctuation')" class="typing-challenge-btn bg-red-500 text-white px-4 py-3 rounded-lg hover:bg-red-600 transition-colors">
                            ‚ö° Punctuation
                        </button>
                        <button onclick="setTypingChallenge('mixed')" class="typing-challenge-btn bg-indigo-500 text-white px-4 py-3 rounded-lg hover:bg-indigo-600 transition-colors">
                            üåà Mixed Challenge
                        </button>
                        <button onclick="setTypingChallenge('speed')" class="typing-challenge-btn bg-yellow-500 text-white px-4 py-3 rounded-lg hover:bg-yellow-600 transition-colors">
                            üèÉ Speed Burst
                        </button>
                        <button onclick="setTypingChallenge('accuracy')" class="typing-challenge-btn bg-pink-500 text-white px-4 py-3 rounded-lg hover:bg-pink-600 transition-colors">
                            üéØ Accuracy Test
                        </button>
                    </div>
                    
                    <div class="mb-4">
                        <label class="mr-3">Duration:</label>
                        <select id="typing-duration" class="px-3 py-2 text-base border rounded">
                            <option value="30">30 seconds</option>
                            <option value="60" selected>1 minute</option>
                            <option value="120">2 minutes</option>
                            <option value="180">3 minutes</option>
                            <option value="300">5 minutes</option>
                        </select>
                    </div>
                </div>

                <div class="mb-4 flex flex-wrap justify-center gap-4">
                    <span class="text-lg font-semibold">WPM: <span id="wpm-display">0</span></span>
                    <span class="text-lg font-semibold">Accuracy: <span id="accuracy-display">100%</span></span>
                    <span class="text-lg font-semibold">Time: <span id="time-display">0s</span></span>
                    <span class="text-lg font-semibold">Challenge: <span id="current-challenge">Common Words</span></span>
                </div>
                
                <div id="text-to-type" class="bg-white dark:bg-gray-800 border-2 border-gray-300 rounded-lg p-4 mb-4 max-w-2xl mx-auto text-lg leading-relaxed font-mono">
                    Choose a challenge and click "Start Test" to begin
                </div>
                
                <textarea id="typing-input" class="w-full max-w-2xl h-32 px-4 py-3 text-base border-2 border-gray-300 rounded-lg focus:ring-2 focus:ring-primary focus:outline-none resize-none font-mono" 
                          placeholder="Start typing here..." oninput="handleTypingInput()" onpaste="return false"></textarea>
                
                <div class="mt-4 space-x-4">
                    <button onclick="startTypingTest()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">Start Test</button>
                    <button onclick="resetTypingTest()" class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-2 rounded-lg transition-colors">Reset</button>
                </div>

                <!-- Results Panel -->
                <div id="typing-results" class="mt-6 p-4 bg-gray-100 dark:bg-gray-800 rounded-lg hidden">
                    <h3 class="text-xl font-semibold mb-3">Test Results</h3>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                        <div>
                            <div class="text-2xl font-bold text-primary" id="final-wpm">0</div>
                            <div class="text-sm text-gray-600 dark:text-gray-400">WPM</div>
                        </div>
                        <div>
                            <div class="text-2xl font-bold text-green-500" id="final-accuracy">100%</div>
                            <div class="text-sm text-gray-600 dark:text-gray-400">Accuracy</div>
                        </div>
                        <div>
                            <div class="text-2xl font-bold text-blue-500" id="final-chars">0</div>
                            <div class="text-sm text-gray-600 dark:text-gray-400">Characters</div>
                        </div>
                        <div>
                            <div class="text-2xl font-bold text-purple-500" id="final-errors">0</div>
                            <div class="text-sm text-gray-600 dark:text-gray-400">Errors</div>
                        </div>
                    </div>
                    <div class="mt-4">
                        <div class="text-lg font-semibold" id="performance-rating">Great job!</div>
                        <div class="text-sm text-gray-600 dark:text-gray-400" id="performance-tips">Keep practicing to improve your speed and accuracy!</div>
                    </div>
                </div>
            </div>
        </div>

       <!-- Tower Defense -->
<div id="tower-defense-page" class="page hidden">
    <div class="flex items-center mb-6">
        <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
            </svg>
        </button>
        <h2 class="text-3xl font-bold">üè∞ Tower Defense</h2>
    </div>

    <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
        <h3 class="text-xl font-semibold mb-3">How to Play</h3>
        <p class="text-gray-600 dark:text-gray-400">Click empty spaces to build towers and defend against enemy waves! Each tower costs money and has different abilities.</p>
    </div>

    <div class="text-center">
        <div class="mb-4 flex flex-wrap justify-center gap-4">
            <span class="text-lg font-semibold">üí∞ Money: <span id="td-money">100</span></span>
            <span class="text-lg font-semibold">‚ù§Ô∏è Lives: <span id="td-lives">20</span></span>
            <span class="text-lg font-semibold">üåä Wave: <span id="td-wave">1</span></span>
            <span class="text-lg font-semibold">üìä Score: <span id="td-score">0</span></span>
        </div>
        
        <!-- Tower Selection -->
        <div class="mb-4 flex flex-wrap justify-center gap-2">
            <button id="basic-tower-btn" onclick="selectTowerType('basic')" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded transition-colors">
                üîµ Basic ($20)
            </button>
            <button id="heavy-tower-btn" onclick="selectTowerType('heavy')" class="px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded transition-colors">
                üî¥ Heavy ($50)
            </button>
            <button id="rapid-tower-btn" onclick="selectTowerType('rapid')" class="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded transition-colors">
                üü¢ Rapid ($35)
            </button>
            <button onclick="sellMode()" class="px-4 py-2 bg-orange-500 hover:bg-orange-600 text-white rounded transition-colors">
                üí∞ Sell (50%)
            </button>
        </div>
        
        <canvas id="td-canvas" class="game-canvas mx-auto mb-4 cursor-pointer" width="600" height="400"></canvas>
        
        <div class="space-x-4">
            <button onclick="startTowerDefense()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">Start Wave</button>
            <button onclick="generateNewMap()" class="bg-green-500 hover:bg-green-600 text-white px-6 py-2 rounded-lg transition-colors">New Map</button>
            <button onclick="resetTowerDefense()" class="bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded-lg transition-colors">Reset Game</button>
        </div>
        <div id="td-status" class="text-xl font-semibold mt-4"></div>
    </div>
</div>

        <!-- Dino Runner -->
        <div id="endless-runner-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">ü¶ñ Dino Runner</h2>
            </div>

            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Tap to jump over obstacles. The longer you survive, the higher your score!</p>
            </div>

            <div class="text-center">
                <div class="mb-4">
                    <span class="text-lg font-semibold">Score: <span id="dino-score">0</span></span>
                    <span class="ml-6 text-lg font-semibold">High Score: <span id="dino-high-score">0</span></span>
                </div>
                <canvas id="dino-canvas" class="game-canvas mx-auto mb-4 cursor-pointer" width="400" height="150" onclick="jumpDino()"></canvas>
                <div id="dino-status" class="text-xl font-semibold mb-4"></div>
                <button onclick="startDinoGame()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">Start Game</button>
            </div>
        </div>

        <!-- Flappy Bird -->
        <div id="flappy-bird-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">üê¶ Flappy Bird</h2>
            </div>

            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Tap anywhere to flap and keep the bird flying through the pipes!</p>
            </div>

            <div class="text-center">
                <div class="mb-4">
                    <span class="text-lg font-semibold">Score: <span id="flappy-score">0</span></span>
                    <span class="ml-6 text-lg font-semibold">Best: <span id="flappy-best">0</span></span>
                </div>
                <canvas id="flappy-canvas" class="game-canvas mx-auto mb-4 cursor-pointer" width="320" height="480" onclick="flapBird()"></canvas>
                <div id="flappy-status" class="text-xl font-semibold mb-4"></div>
                <button onclick="startFlappyBird()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">Start Game</button>
            </div>
        </div>

        <!-- Shape Drawing -->
        <div id="shape-drawing-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">üìê Shape Drawing</h2>
            </div>
            
            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Select a shape and click on the canvas to draw perfect geometric shapes!</p>
            </div>

            <div class="text-center">
                <div class="mb-4 flex flex-wrap justify-center gap-2">
                    <button class="shape-btn" onclick="setCurrentShape('circle')">‚óè Circle</button>
                    <button class="shape-btn" onclick="setCurrentShape('square')">‚ñ† Square</button>
                    <button class="shape-btn" onclick="setCurrentShape('triangle')">‚ñ≤ Triangle</button>
                    <button class="shape-btn" onclick="setCurrentShape('line')">‚Äî Line</button>
                </div>
                <div class="mb-4">
                    <label class="mr-2">Color:</label>
                    <input type="color" id="shape-color" value="#5D5CDE" onchange="setShapeColor(this.value)">
                    <label class="ml-4 mr-2">Size:</label>
                    <input type="range" id="shape-size" min="10" max="100" value="30" onchange="setShapeSize(this.value)">
                    <span id="shape-size-display" class="ml-2">30px</span>
                </div>
                <canvas id="shape-canvas" class="game-canvas mx-auto mb-4 cursor-crosshair" width="600" height="400"></canvas>
                <div class="space-y-4">
                    <button onclick="clearShapeCanvas()" class="bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded-lg transition-colors">Clear Canvas</button>
                </div>
            </div>
        </div>

        <!-- Dot Connect -->
        <div id="dot-connect-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">‚ö´ Dot Connect</h2>
            </div>
            
            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Connect the numbered dots in order to reveal a hidden picture!</p>
            </div>

            <div class="text-center">
                <div class="mb-4">
                    <span class="text-lg font-semibold">Current Dot: <span id="dot-current">1</span></span>
                    <span class="ml-6 text-lg font-semibold">Progress: <span id="dot-progress">0</span>/<span id="dot-total">10</span></span>
                </div>
                <canvas id="dot-canvas" class="game-canvas mx-auto mb-4" width="400" height="400"></canvas>
                <div class="space-x-4">
                    <button onclick="generateDotPuzzle()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">New Puzzle</button>
                    <button onclick="clearDotConnections()" class="bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded-lg transition-colors">Clear Lines</button>
                </div>
                <div id="dot-result" class="text-xl font-semibold mt-4"></div>
            </div>
        </div>

        <!-- Pattern Match -->
        <div id="pattern-match-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">üé≠ Pattern Match</h2>
            </div>
            
            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Copy the pattern shown by clicking on the grid cells!</p>
            </div>

            <div class="text-center">
                <div class="mb-4 flex justify-center gap-8">
                    <span class="text-lg font-semibold">Level: <span id="pattern-level">1</span></span>
                    <span class="text-lg font-semibold">Score: <span id="pattern-score">0</span></span>
                </div>
                
                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-3">Target Pattern:</h3>
                    <div id="pattern-target" class="inline-block bg-gray-200 dark:bg-gray-700 p-4 rounded-lg mb-4">
                        <!-- Target pattern grid will be generated here -->
                    </div>
                </div>
                
                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-3">Your Pattern:</h3>
                    <div id="pattern-player" class="inline-block bg-gray-200 dark:bg-gray-700 p-4 rounded-lg mb-4">
                        <!-- Player pattern grid will be generated here -->
                    </div>
                </div>
                
                <div class="space-x-4">
                    <button onclick="checkPatternMatch()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">Check Pattern</button>
                    <button onclick="clearPlayerPattern()" class="bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded-lg transition-colors">Clear</button>
                    <button onclick="generateNewPattern()" class="bg-green-500 hover:bg-green-600 text-white px-6 py-2 rounded-lg transition-colors">Next Pattern</button>
                </div>
                <div id="pattern-result" class="text-xl font-semibold mt-4"></div>
            </div>
        </div>

        <!-- Color Mixer -->
        <div id="color-mixer-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">üåà Color Mixer</h2>
            </div>
            
            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Adjust the RGB sliders to match the target color as closely as possible!</p>
            </div>

            <div class="text-center">
                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-3">Target Color:</h3>
                    <div id="target-color" class="w-32 h-32 mx-auto rounded-lg border-4 border-gray-300 mb-4"></div>
                    <div class="text-sm text-gray-600 dark:text-gray-400">Match this color!</div>
                </div>
                
                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-3">Your Color:</h3>
                    <div id="player-color" class="w-32 h-32 mx-auto rounded-lg border-4 border-gray-300 mb-4"></div>
                    <div class="text-sm">RGB: <span id="player-rgb">(128, 128, 128)</span></div>
                </div>

                <div class="max-w-md mx-auto mb-6 space-y-4">
                    <div class="flex items-center justify-between">
                        <label class="text-red-500 font-semibold">Red:</label>
                        <input type="range" id="red-slider" min="0" max="255" value="128" onchange="updatePlayerColor()" class="flex-1 mx-4">
                        <span id="red-value" class="w-8 text-sm">128</span>
                    </div>
                    <div class="flex items-center justify-between">
                        <label class="text-green-500 font-semibold">Green:</label>
                        <input type="range" id="green-slider" min="0" max="255" value="128" onchange="updatePlayerColor()" class="flex-1 mx-4">
                        <span id="green-value" class="w-8 text-sm">128</span>
                    </div>
                    <div class="flex items-center justify-between">
                        <label class="text-blue-500 font-semibold">Blue:</label>
                        <input type="range" id="blue-slider" min="0" max="255" value="128" onchange="updatePlayerColor()" class="flex-1 mx-4">
                        <span id="blue-value" class="w-8 text-sm">128</span>
                    </div>
                </div>

                <div class="mb-4">
                    <div class="text-lg font-semibold">Accuracy: <span id="color-accuracy">0%</span></div>
                    <div class="text-sm text-gray-600 dark:text-gray-400">Score: <span id="color-score">0</span></div>
                </div>

                <div class="space-x-4">
                    <button onclick="checkColorMatch()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">Check Match</button>
                    <button onclick="generateNewTargetColor()" class="bg-green-500 hover:bg-green-600 text-white px-6 py-2 rounded-lg transition-colors">New Color</button>
                </div>
            </div>
        </div>

        <!-- Anagram Game -->
        <div id="anagram-game-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">üî§ Anagram Game</h2>
            </div>
            
            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Unscramble the letters to form the correct word! Click letters to build your answer.</p>
            </div>

            <div class="text-center">
                <div class="mb-4 flex justify-center gap-8">
                    <span class="text-lg font-semibold">Score: <span id="anagram-score">0</span></span>
                    <span class="text-lg font-semibold">Round: <span id="anagram-round">1</span></span>
                </div>
                <div class="mb-6">
                    <div class="text-sm text-gray-600 dark:text-gray-400 mb-2">Unscramble this word:</div>
                    <div id="anagram-scrambled" class="text-2xl font-bold mb-4 tracking-wide">EXAMPLE</div>
                    <div class="text-sm text-gray-600 dark:text-gray-400 mb-4">Hint: <span id="anagram-hint">A sample or illustration</span></div>
                </div>
                <div id="anagram-letters" class="flex flex-wrap justify-center gap-2 mb-6 min-h-12">
                    <!-- Scrambled letters will appear here -->
                </div>
                <div class="mb-6">
                    <div class="text-lg mb-2">Your Answer:</div>
                    <div id="anagram-answer" class="bg-white dark:bg-gray-800 border-2 border-gray-300 rounded-lg p-4 min-h-12 text-xl font-semibold">
                        <!-- Player's answer will appear here -->
                    </div>
                </div>
                <div class="space-x-4">
                    <button onclick="clearAnagramAnswer()" class="bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded-lg transition-colors">Clear</button>
                    <button onclick="checkAnagramAnswer()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">Check Answer</button>
                    <button onclick="nextAnagram()" class="bg-green-500 hover:bg-green-600 text-white px-6 py-2 rounded-lg transition-colors">Next Word</button>
                </div>
                <div id="anagram-result" class="text-xl font-semibold mt-4"></div>
            </div>
        </div>

        <!-- Sliding Puzzle -->
        <div id="sliding-puzzle-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">üîÄ Sliding Puzzle</h2>
            </div>
            
            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Click on tiles next to the empty space to slide them. Arrange the numbers 1-15 in order!</p>
            </div>

            <div class="text-center">
                <div class="mb-4 flex justify-center gap-8">
                    <span class="text-lg font-semibold">Moves: <span id="sliding-moves">0</span></span>
                    <span class="text-lg font-semibold">Time: <span id="sliding-time">00:00</span></span>
                </div>
                <div id="sliding-grid" class="inline-block bg-gray-300 dark:bg-gray-600 p-2 rounded-lg mb-4">
                    <!-- 4x4 grid will be generated here -->
                </div>
                <div class="space-x-4">
                    <button onclick="shuffleSlidingPuzzle()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">Shuffle</button>
                    <button onclick="resetSlidingPuzzle()" class="bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded-lg transition-colors">Reset</button>
                </div>
                <div id="sliding-result" class="text-xl font-semibold mt-4"></div>
            </div>
        </div>

        <!-- Math Quiz -->
        <div id="math-quiz-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">‚ûï Math Challenge</h2>
            </div>
            
            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Choose your math category and solve problems as quickly as possible!</p>
            </div>

            <div class="text-center">
                <!-- Category Selection -->
                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-3">Select Category:</h3>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-3 max-w-4xl mx-auto mb-4">
                        <button onclick="setMathCategory('arithmetic')" class="math-category-btn bg-blue-500 text-white px-4 py-3 rounded-lg hover:bg-blue-600 transition-colors">
                            ‚ûï Arithmetic<br><span class="text-sm">Basic operations</span>
                        </button>
                        <button onclick="setMathCategory('fractions')" class="math-category-btn bg-green-500 text-white px-4 py-3 rounded-lg hover:bg-green-600 transition-colors">
                            ¬Ω Fractions<br><span class="text-sm">Parts and wholes</span>
                        </button>
                        <button onclick="setMathCategory('percentages')" class="math-category-btn bg-purple-500 text-white px-4 py-3 rounded-lg hover:bg-purple-600 transition-colors">
                            % Percentages<br><span class="text-sm">Percent calculations</span>
                        </button>
                        <button onclick="setMathCategory('algebra')" class="math-category-btn bg-red-500 text-white px-4 py-3 rounded-lg hover:bg-red-600 transition-colors">
                            üî§ Algebra<br><span class="text-sm">Solve for X</span>
                        </button>
                        <button onclick="setMathCategory('geometry')" class="math-category-btn bg-orange-500 text-white px-4 py-3 rounded-lg hover:bg-orange-600 transition-colors">
                            üìê Geometry<br><span class="text-sm">Shapes and areas</span>
                        </button>
                        <button onclick="setMathCategory('word-problems')" class="math-category-btn bg-indigo-500 text-white px-4 py-3 rounded-lg hover:bg-indigo-600 transition-colors">
                            üìù Word Problems<br><span class="text-sm">Real-world math</span>
                        </button>
                        <button onclick="setMathCategory('mental-math')" class="math-category-btn bg-yellow-500 text-white px-4 py-3 rounded-lg hover:bg-yellow-600 transition-colors">
                            üß† Mental Math<br><span class="text-sm">Quick calculations</span>
                        </button>
                        <button onclick="setMathCategory('mixed')" class="math-category-btn bg-pink-500 text-white px-4 py-3 rounded-lg hover:bg-pink-600 transition-colors">
                            üåà Mixed<br><span class="text-sm">All categories</span>
                        </button>
                    </div>
                    
                    <div class="mb-4">
                        <label class="mr-3">Difficulty:</label>
                        <select id="math-difficulty" onchange="setMathDifficulty()" class="px-3 py-2 text-base border rounded mr-4">
                            <option value="easy">Easy</option>
                            <option value="medium" selected>Medium</option>
                            <option value="hard">Hard</option>
                            <option value="expert">Expert</option>
                        </select>
                        
                        <label class="mr-3 ml-4">Mode:</label>
                        <select id="math-mode" class="px-3 py-2 text-base border rounded">
                            <option value="timed">Timed (60s)</option>
                            <option value="endless">Endless</option>
                            <option value="sprint">Sprint (10 questions)</option>
                        </select>
                    </div>
                </div>

                <div class="mb-4 flex flex-wrap justify-center gap-4">
                    <span class="text-lg font-semibold">Score: <span id="math-score">0</span></span>
                    <span class="text-lg font-semibold">Streak: <span id="math-streak">0</span></span>
                    <span class="text-lg font-semibold">Time: <span id="math-time">0s</span></span>
                    <span class="text-lg font-semibold">Category: <span id="current-math-category">Arithmetic</span></span>
                </div>
                
                <div id="math-question" class="bg-white dark:bg-gray-800 border-2 border-gray-300 rounded-lg p-8 mb-6 max-w-md mx-auto">
                    <div id="math-problem" class="text-3xl font-bold mb-4">Choose category and click Start</div>
                </div>
                
                <div id="math-options" class="grid grid-cols-2 gap-4 max-w-md mx-auto mb-6">
                    <!-- Options will be populated here -->
                </div>
                
                <div id="math-result" class="text-xl font-semibold mb-4"></div>
                <button id="math-start-btn" onclick="startMathQuiz()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">Start Quiz</button>
                
                <!-- Results Panel -->
                <div id="math-results" class="mt-6 p-4 bg-gray-100 dark:bg-gray-800 rounded-lg hidden">
                    <h3 class="text-xl font-semibold mb-3">Quiz Results</h3>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                        <div>
                            <div class="text-2xl font-bold text-primary" id="final-math-score">0</div>
                            <div class="text-sm text-gray-600 dark:text-gray-400">Final Score</div>
                        </div>
                        <div>
                            <div class="text-2xl font-bold text-green-500" id="final-math-correct">0</div>
                            <div class="text-sm text-gray-600 dark:text-gray-400">Correct</div>
                        </div>
                        <div>
                            <div class="text-2xl font-bold text-red-500" id="final-math-wrong">0</div>
                            <div class="text-sm text-gray-600 dark:text-gray-400">Wrong</div>
                        </div>
                        <div>
                            <div class="text-2xl font-bold text-purple-500" id="final-math-accuracy">100%</div>
                            <div class="text-sm text-gray-600 dark:text-gray-400">Accuracy</div>
                        </div>
                    </div>
                    <div class="mt-4">
                        <div class="text-lg font-semibold" id="math-performance-rating">Great job!</div>
                        <div class="text-sm text-gray-600 dark:text-gray-400" id="math-performance-tips">Keep practicing to improve your skills!</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Number Sequence -->
        <div id="number-sequence-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">üî¢ Number Sequence</h2>
            </div>
            
            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Memorize the sequence of numbers, then repeat it back in the correct order!</p>
            </div>

            <div class="text-center">
                <div class="mb-4 flex justify-center gap-8">
                    <span class="text-lg font-semibold">Level: <span id="sequence-level">1</span></span>
                    <span class="text-lg font-semibold">Best: <span id="sequence-best">1</span></span>
                </div>
                
                <div id="sequence-status" class="text-xl font-semibold mb-6">Click Start to begin</div>
                
                <div id="sequence-display" class="bg-white dark:bg-gray-800 border-2 border-gray-300 rounded-lg p-8 mb-6 max-w-md mx-auto min-h-24 flex items-center justify-center">
                    <div id="sequence-numbers" class="text-4xl font-bold">Ready?</div>
                </div>
                
                <div id="sequence-input" class="mb-6 hidden">
                    <div class="text-lg mb-3">Click the numbers in order:</div>
                    <div id="sequence-buttons" class="grid grid-cols-5 gap-2 max-w-md mx-auto">
                        <!-- Number buttons will be generated here -->
                    </div>
                </div>
                
                <div class="space-x-4">
                    <button id="sequence-start-btn" onclick="startSequenceGame()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">Start Game</button>
                    <button onclick="resetSequenceGame()" class="bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded-lg transition-colors">Reset</button>
                </div>
            </div>
        </div>

        <!-- Reflex Test -->
        <div id="reflex-test-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">üëÅÔ∏è Reflex Test</h2>
            </div>
            
            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Click when the shapes match to test your visual reflexes!</p>
            </div>

            <div class="text-center">
                <div class="mb-4 flex justify-center gap-8">
                    <span class="text-lg font-semibold">Score: <span id="reflex-score">0</span></span>
                    <span class="text-lg font-semibold">Hits: <span id="reflex-hits">0</span></span>
                    <span class="text-lg font-semibold">Misses: <span id="reflex-misses">0</span></span>
                </div>
                
                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-3">Target Shape:</h3>
                    <div id="reflex-target" class="flex justify-center mb-4">
                        <div id="target-shape" class="w-16 h-16 bg-blue-500 rounded-full"></div>
                    </div>
                </div>
                
                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-3">Click when they match:</h3>
                    <div id="reflex-test-area" class="w-full max-w-md mx-auto h-32 bg-gray-200 dark:bg-gray-700 rounded-lg flex items-center justify-center cursor-pointer" onclick="handleReflexClick()">
                        <div id="test-shape" class="w-16 h-16 bg-red-500 rounded-full transition-all duration-300"></div>
                    </div>
                </div>
                
                <div class="space-x-4">
                    <button id="reflex-start-btn" onclick="startReflexTest()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">Start Test</button>
                    <button onclick="resetReflexTest()" class="bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded-lg transition-colors">Reset</button>
                </div>
                <div id="reflex-result" class="text-xl font-semibold mt-4"></div>
            </div>
        </div>

        <!-- Memory Cards -->
        <div id="memory-cards-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">üÉè Memory Cards</h2>
            </div>
            
            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Watch the sequence of cards light up, then click them in the same order!</p>
            </div>

            <div class="text-center">
                <div class="mb-4 flex justify-center gap-8">
                    <span class="text-lg font-semibold">Level: <span id="cards-level">1</span></span>
                    <span class="text-lg font-semibold">Best: <span id="cards-best">1</span></span>
                </div>
                
                <div id="cards-status" class="text-xl font-semibold mb-6">Click Start to begin</div>
                
                <div id="cards-grid" class="grid grid-cols-3 gap-4 max-w-xs mx-auto mb-6">
                    <!-- Cards will be generated here -->
                </div>
                
                <div class="space-x-4">
                    <button id="cards-start-btn" onclick="startMemoryCards()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">Start Game</button>
                    <button onclick="resetMemoryCards()" class="bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded-lg transition-colors">Reset</button>
                </div>
            </div>
        </div>

        <!-- Breakout -->
        <div id="breakout-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">üß± Breakout</h2>
            </div>
            
            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Use your paddle to bounce the ball and break all the bricks! Move by touching the screen or using arrow keys.</p>
            </div>

            <div class="text-center">
                <div class="mb-4 flex justify-center gap-8">
                    <span class="text-lg font-semibold">Score: <span id="breakout-score">0</span></span>
                    <span class="text-lg font-semibold">Lives: <span id="breakout-lives">3</span></span>
                </div>
                <canvas id="breakout-canvas" class="game-canvas mx-auto mb-4" width="400" height="300"></canvas>
                <div id="breakout-status" class="text-xl font-semibold mb-4"></div>
                <button onclick="startBreakout()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">Start Game</button>
            </div>
        </div>

        <!-- Catch Game -->
        <div id="catch-game-page" class="page hidden">
            <div class="flex items-center mb-6">
                <button onclick="showPage('home')" class="text-primary hover:text-primary-dark mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <h2 class="text-3xl font-bold">üé£ Catch Game</h2>
            </div>
            
            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-3">How to Play</h3>
                <p class="text-gray-600 dark:text-gray-400">Move your basket to catch falling fruits while avoiding bombs! Use touch or arrow keys to move.</p>
            </div>

            <div class="text-center">
                <div class="mb-4 flex justify-center gap-8">
                    <span class="text-lg font-semibold">Score: <span id="catch-score">0</span></span>
                    <span class="text-lg font-semibold">Lives: <span id="catch-lives">3</span></span>
                    <span class="text-lg font-semibold">Level: <span id="catch-level">1</span></span>
                </div>
                
                <canvas id="catch-canvas" class="game-canvas mx-auto mb-4 cursor-pointer" width="400" height="300"></canvas>
                
                <div class="space-x-4">
                    <button onclick="startCatchGame()" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">Start Game</button>
                    <button onclick="resetCatchGame()" class="bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded-lg transition-colors">Reset</button>
                </div>
                <div id="catch-status" class="text-xl font-semibold mt-4"></div>
            </div>
        </div>
    </main>

    <script>
        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Global variables for current game
        let currentGame = '';
        let currentGameRunning = false;

        // Games database
        const games = {
            // Drawing Games (6 total)
            'paint-canvas': { name: 'Paint Canvas', category: 'drawing', emoji: 'üé®', description: 'Express your creativity with this digital painting tool!' },
            'pixel-art': { name: 'Pixel Art', category: 'drawing', emoji: 'üü¶', description: 'Create beautiful pixel art on a grid canvas!' },
            'shape-drawing': { name: 'Shape Drawing', category: 'drawing', emoji: 'üìê', description: 'Draw perfect geometric shapes with ease!' },
            'dot-connect': { name: 'Dot Connect', category: 'drawing', emoji: '‚ö´', description: 'Connect numbered dots to reveal hidden pictures!' },
            'pattern-match': { name: 'Pattern Match', category: 'drawing', emoji: 'üé≠', description: 'Copy the pattern shown as accurately as possible!' },
            'color-mixer': { name: 'Color Mixer', category: 'drawing', emoji: 'üåà', description: 'Mix RGB colors to match the target color!' },
            
            // Puzzle Games (6 total)
            'memory-match': { name: 'Memory Match', category: 'puzzle', emoji: 'üß†', description: 'Challenge your memory with this classic card matching game!' },
            'game-2048': { name: '2048', category: 'puzzle', emoji: 'üî¢', description: 'Combine tiles to reach the 2048 tile in this addictive puzzle game!' },
            'word-guess': { name: 'Word Guess', category: 'puzzle', emoji: 'üî§', description: 'Guess the 5-letter word in 6 tries!' },
            'anagram-game': { name: 'Anagram Game', category: 'puzzle', emoji: 'üî§', description: 'Unscramble letters to form words!' },
            'sliding-puzzle': { name: 'Sliding Puzzle', category: 'puzzle', emoji: 'üîÄ', description: 'Slide tiles to arrange them in the correct order!' },
            'math-quiz': { name: 'Math Quiz', category: 'puzzle', emoji: '‚ûï', description: 'Test your math skills with quick calculations!' },
            
            // Skill Games (6 total)
            'reaction-time': { name: 'Reaction Time', category: 'skill', emoji: '‚ö°', description: 'Test how fast your reflexes really are!' },
            'typing-speed': { name: 'Typing Speed', category: 'skill', emoji: '‚å®Ô∏è', description: 'Test and improve your typing speed with this WPM challenge!' },
            'click-accuracy': { name: 'Click Accuracy', category: 'skill', emoji: 'üéØ', description: 'Test your precision by clicking on moving targets!' },
            'number-sequence': { name: 'Number Sequence', category: 'skill', emoji: 'üî¢', description: 'Remember and repeat increasingly long number sequences!' },
            'reflex-test': { name: 'Reflex Test', category: 'skill', emoji: 'üëÅÔ∏è', description: 'Click when shapes match to test your visual reflexes!' },
            'memory-cards': { name: 'Memory Cards', category: 'skill', emoji: 'üÉè', description: 'Remember the sequence and click cards in order!' },
            
            // Arcade Games (6 total)
            'snake-game': { name: 'Snake Game', category: 'arcade', emoji: 'üêç', description: 'Classic snake game - eat food and grow longer!' },
            'tower-defense': { name: 'Tower Defense', category: 'arcade', emoji: 'üè∞', description: 'Build towers to defend against enemy waves!' },
            'breakout': { name: 'Breakout', category: 'arcade', emoji: 'üß±', description: 'Break all the bricks with your paddle and ball!' },
            'endless-runner': { name: 'Dino Runner', category: 'arcade', emoji: 'ü¶ñ', description: 'Jump over obstacles in this endless running adventure!' },
            'flappy-bird': { name: 'Flappy Bird', category: 'arcade', emoji: 'üê¶', description: 'Flap through pipes in this challenging flying game!' },
            'catch-game': { name: 'Catch Game', category: 'arcade', emoji: 'üé£', description: 'Catch falling items while avoiding bombs!' }
        };

        // Navigation functions
        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => page.classList.add('hidden'));
            document.getElementById(pageId + '-page').classList.remove('hidden');
            currentGame = pageId;
            updateMobileButton();
        }

        function showCategory(category) {
            const categoryGames = Object.entries(games).filter(([id, game]) => game.category === category);
            const categoryPage = document.getElementById('category-page');
            const categoryTitle = document.getElementById('category-title');
            const categoryGamesContainer = document.getElementById('category-games');

            categoryTitle.textContent = category.charAt(0).toUpperCase() + category.slice(1) + ' Games';
            
            categoryGamesContainer.innerHTML = categoryGames.map(([id, game]) => `
                <div class="game-card bg-gray-100 dark:bg-gray-800 rounded-lg p-6 cursor-pointer hover:shadow-lg transition-shadow" onclick="showGame('${id}')">
                    <div class="text-4xl mb-3">${game.emoji}</div>
                    <h4 class="text-lg font-semibold mb-2">${game.name}</h4>
                    <p class="text-gray-600 dark:text-gray-400">${game.description}</p>
                </div>
            `).join('');

            showPage('category');
        }

        function showGame(gameId) {
            showPage(gameId);
            currentGame = gameId;
            currentGameRunning = false;
            
            // Initialize games
            setTimeout(() => {
                // Drawing Games
                if (gameId === 'paint-canvas') setupPaintCanvas();
                if (gameId === 'pixel-art') setupPixelArt();
                if (gameId === 'shape-drawing') setupShapeDrawing();
                if (gameId === 'dot-connect') setupDotConnect();
                if (gameId === 'pattern-match') setupPatternMatch();
                if (gameId === 'color-mixer') setupColorMixer();
                
                // Puzzle Games
                if (gameId === 'memory-match') resetMemoryGame();
                if (gameId === 'game-2048') init2048();
                if (gameId === 'word-guess') setupWordGuess();
                if (gameId === 'anagram-game') setupAnagramGame();
                if (gameId === 'sliding-puzzle') setupSlidingPuzzle();
                if (gameId === 'math-quiz') setupMathQuiz();
                
                // Skill Games
                if (gameId === 'reaction-time') resetReactionTest();
                if (gameId === 'typing-speed') startTypingTest();
                if (gameId === 'click-accuracy') resetAccuracyGame();
                if (gameId === 'number-sequence') setupNumberSequence();
                if (gameId === 'reflex-test') setupReflexTest();
                if (gameId === 'memory-cards') setupMemoryCards();
                
                // Arcade Games
                if (gameId === 'snake-game') setupSnakeGame();
                if (gameId === 'tower-defense') setupTowerDefense();
                if (gameId === 'breakout') setupBreakout();
                if (gameId === 'endless-runner') setupDinoGame();
                if (gameId === 'flappy-bird') setupFlappyBird();
                if (gameId === 'catch-game') setupCatchGame();
            }, 100);
        }

        function toggleMobileMenu() {
            const menu = document.getElementById('mobile-menu');
            menu.classList.toggle('hidden');
        }

        function searchGames(query) {
            if (!query) return;
            
            const results = Object.entries(games).filter(([id, game]) => 
                game.name.toLowerCase().includes(query.toLowerCase()) ||
                game.description.toLowerCase().includes(query.toLowerCase())
            );

            if (results.length > 0) {
                showGame(results[0][0]);
            }
        }

        // Mobile action button
        function updateMobileButton() {
            const actionBtn = document.getElementById('mobile-action-btn');
            const resetBtn = document.getElementById('reset-btn');
            
            if (currentGame && currentGame !== 'home' && currentGame !== 'category') {
                actionBtn.style.display = 'flex';
                resetBtn.style.display = 'flex';
                
                if (currentGameRunning) {
                    actionBtn.textContent = '‚è∏';
                    actionBtn.onclick = () => stopCurrentGame();
                } else {
                    actionBtn.textContent = '‚ñ∂';
                    actionBtn.onclick = () => startCurrentGame();
                }
            } else {
                actionBtn.style.display = 'none';
                resetBtn.style.display = 'none';
            }
        }

        // Reset current game function
        function resetCurrentGame() {
            // Stop any running game first
            stopCurrentGame();
            
            // Call the appropriate reset function for each game
            if (currentGame === 'paint-canvas') setupPaintCanvas();
            if (currentGame === 'pixel-art') setupPixelArt();
            if (currentGame === 'snake-game') setupSnakeGame();
            if (currentGame === 'game-2048') init2048();
            if (currentGame === 'memory-match') resetMemoryGame();
            if (currentGame === 'reaction-time') resetReactionTest();
            if (currentGame === 'click-accuracy') resetAccuracyGame();
            if (currentGame === 'flappy-bird') setupFlappyBird();
            if (currentGame === 'sudoku') generateSudoku();
            if (currentGame === 'typing-speed') startTypingTest();
            if (currentGame === 'tower-defense') setupTowerDefense();
            if (currentGame === 'endless-runner') setupDinoGame();
            
            // Reset game state
            currentGameRunning = false;
            updateMobileButton();
        }

        function handleMobileAction() {
            if (currentGameRunning) {
                stopCurrentGame();
            } else {
                startCurrentGame();
            }
        }

        function startCurrentGame() {
            if (currentGame === 'snake-game') startSnakeGame();
            if (currentGame === 'reaction-time') startReactionTest();
            if (currentGame === 'click-accuracy') startAccuracyGame();
            if (currentGame === 'flappy-bird') startFlappyBird();
            currentGameRunning = true;
            updateMobileButton();
        }

        function stopCurrentGame() {
            if (currentGame === 'snake-game') snakeGameRunning = false;
            if (currentGame === 'flappy-bird') flappyGameRunning = false;
            if (currentGame === 'click-accuracy') accuracyGameRunning = false;
            currentGameRunning = false;
            updateMobileButton();
        }

        // Paint Canvas
        let paintCanvas, paintCtx;
        let isPainting = false;
        let currentColor = '#000000';
        let currentBrushSize = 5;
        let isEraser = false;

        function setupPaintCanvas() {
            paintCanvas = document.getElementById('paint-canvas');
            if (!paintCanvas) return;
            
            paintCtx = paintCanvas.getContext('2d');
            paintCtx.lineCap = 'round';
            paintCtx.lineJoin = 'round';
            
            // Remove existing listeners
            paintCanvas.onmousedown = null;
            paintCanvas.onmousemove = null;
            paintCanvas.onmouseup = null;
            paintCanvas.ontouchstart = null;
            paintCanvas.ontouchmove = null;
            paintCanvas.ontouchend = null;
            
            // Mouse events
            paintCanvas.onmousedown = startPainting;
            paintCanvas.onmousemove = paint;
            paintCanvas.onmouseup = stopPainting;
            
            // Touch events
            paintCanvas.ontouchstart = (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = paintCanvas.getBoundingClientRect();
                const mouseEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };
                startPainting(mouseEvent);
            };
            
            paintCanvas.ontouchmove = (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };
                paint(mouseEvent);
            };
            
            paintCanvas.ontouchend = (e) => {
                e.preventDefault();
                stopPainting();
            };
            
            clearPaintCanvas();
        }

        function startPainting(e) {
            isPainting = true;
            const rect = paintCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (paintCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (paintCanvas.height / rect.height);
            paintCtx.beginPath();
            paintCtx.moveTo(x, y);
        }

        function paint(e) {
            if (!isPainting) return;
            const rect = paintCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (paintCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (paintCanvas.height / rect.height);
            
            if (isEraser) {
                paintCtx.globalCompositeOperation = 'destination-out';
            } else {
                paintCtx.globalCompositeOperation = 'source-over';
            }
            
            paintCtx.lineTo(x, y);
            paintCtx.stroke();
        }

        function stopPainting() {
            isPainting = false;
            paintCtx.beginPath();
        }

        function setPaintColor(color) {
            currentColor = color;
            isEraser = false;
            paintCtx.strokeStyle = color;
            paintCtx.globalCompositeOperation = 'source-over';
        }

        function setEraser() {
            isEraser = true;
            paintCtx.globalCompositeOperation = 'destination-out';
        }

        function setBrushSize(size) {
            currentBrushSize = size;
            paintCtx.lineWidth = size;
            document.getElementById('brush-size-display').textContent = size + 'px';
        }

        function clearPaintCanvas() {
            paintCtx.globalCompositeOperation = 'source-over';
            paintCtx.fillStyle = '#ffffff';
            paintCtx.fillRect(0, 0, paintCanvas.width, paintCanvas.height);
            paintCtx.strokeStyle = currentColor;
            paintCtx.lineWidth = currentBrushSize;
        }

        function downloadPainting() {
            const link = document.createElement('a');
            link.download = 'my-painting.png';
            link.href = paintCanvas.toDataURL();
            link.click();
        }

        // Snake Game with improved mobile controls
        let snakeCanvas, snakeCtx;
        let snake, food, dx, dy, snakeScore;
        let snakeGameRunning = false;
        let snakeTouchStartX = 0;
        let snakeTouchStartY = 0;

        function setupSnakeGame() {
            snakeCanvas = document.getElementById('snake-canvas');
            if (!snakeCanvas) return;
            
            snakeCtx = snakeCanvas.getContext('2d');
            initSnakeGame();
            
            // Remove existing listeners
            snakeCanvas.ontouchstart = null;
            snakeCanvas.ontouchend = null;
            
            // Touch events for swipe
            snakeCanvas.ontouchstart = (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                snakeTouchStartX = touch.clientX;
                snakeTouchStartY = touch.clientY;
            };
            
            snakeCanvas.ontouchend = (e) => {
                e.preventDefault();
                if (!snakeTouchStartX || !snakeTouchStartY || !snakeGameRunning) return;

                const touch = e.changedTouches[0];
                const diffX = snakeTouchStartX - touch.clientX;
                const diffY = snakeTouchStartY - touch.clientY;

                if (Math.abs(diffX) > Math.abs(diffY)) {
                    if (diffX > 20 && dx === 0) {
                        setSnakeDirection(-16, 0);
                    } else if (diffX < -20 && dx === 0) {
                        setSnakeDirection(16, 0);
                    }
                } else {
                    if (diffY > 20 && dy === 0) {
                        setSnakeDirection(0, -16);
                    } else if (diffY < -20 && dy === 0) {
                        setSnakeDirection(0, 16);
                    }
                }

                snakeTouchStartX = 0;
                snakeTouchStartY = 0;
            };

            // Keyboard events
            document.onkeydown = (e) => {
                if (!snakeGameRunning || currentGame !== 'snake-game') return;
                
                const key = e.key.toLowerCase();
                if ((key === 'arrowup' || key === 'w') && dy === 0) {
                    setSnakeDirection(0, -16);
                } else if ((key === 'arrowdown' || key === 's') && dy === 0) {
                    setSnakeDirection(0, 16);
                } else if ((key === 'arrowleft' || key === 'a') && dx === 0) {
                    setSnakeDirection(-16, 0);
                } else if ((key === 'arrowright' || key === 'd') && dx === 0) {
                    setSnakeDirection(16, 0);
                }
            };
        }

        function initSnakeGame() {
            snake = [{ x: 160, y: 160 }];
            food = generateSnakeFood();
            dx = 0;
            dy = 0;
            snakeScore = 0;
            snakeGameRunning = false;
            updateSnakeScore();
            drawSnakeGame();
        }

        function startSnakeGame() {
            if (snakeGameRunning) return;
            snakeGameRunning = true;
            currentGameRunning = true;
            dx = 16;
            dy = 0;
            updateMobileButton();
            snakeGameLoop();
        }

        function setSnakeDirection(newDx, newDy) {
            if ((newDx === 16 && dx === -16) || (newDx === -16 && dx === 16) ||
                (newDy === 16 && dy === -16) || (newDy === -16 && dy === 16)) {
                return;
            }
            dx = newDx;
            dy = newDy;
        }

        function snakeGameLoop() {
            if (!snakeGameRunning) return;
            
            setTimeout(() => {
                clearSnakeCanvas();
                moveSnake();
                
                if (checkSnakeCollision()) {
                    snakeGameRunning = false;
                    currentGameRunning = false;
                    updateMobileButton();
                    alert(`Game Over! Final Score: ${snakeScore}`);
                    return;
                }
                
                if (snake[0].x === food.x && snake[0].y === food.y) {
                    snakeScore += 10;
                    updateSnakeScore();
                    snake.push({ x: snake[snake.length - 1].x, y: snake[snake.length - 1].y });
                    food = generateSnakeFood();
                }
                
                drawSnakeGame();
                snakeGameLoop();
            }, 200);
        }

        function moveSnake() {
            const head = { x: snake[0].x + dx, y: snake[0].y + dy };
            snake.unshift(head);
            snake.pop();
        }

        function checkSnakeCollision() {
            const head = snake[0];
            
            if (head.x < 0 || head.x >= 320 || head.y < 0 || head.y >= 320) {
                return true;
            }
            
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return true;
                }
            }
            
            return false;
        }

        function generateSnakeFood() {
            return {
                x: Math.floor(Math.random() * 20) * 16,
                y: Math.floor(Math.random() * 20) * 16
            };
        }

        function drawSnakeGame() {
            snakeCtx.fillStyle = '#5D5CDE';
            snake.forEach(segment => {
                snakeCtx.fillRect(segment.x, segment.y, 14, 14);
            });
            
            snakeCtx.fillStyle = '#EF4444';
            snakeCtx.fillRect(food.x, food.y, 14, 14);
        }

        function clearSnakeCanvas() {
            snakeCtx.clearRect(0, 0, snakeCanvas.width, snakeCanvas.height);
        }

        function updateSnakeScore() {
            document.getElementById('snake-score').textContent = snakeScore;
        }

        // 2048 Game with touch support
        let game2048Board = [];
        let game2048Score = 0;
        let game2048TouchStartX = 0;
        let game2048TouchStartY = 0;

        function init2048() {
            game2048Board = Array(4).fill().map(() => Array(4).fill(0));
            game2048Score = 0;
            addRandomTile();
            addRandomTile();
            render2048();
            
            const container = document.getElementById('game-2048-container');
            if (!container) return;
            
            container.ontouchstart = (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                game2048TouchStartX = touch.clientX;
                game2048TouchStartY = touch.clientY;
            };
            
            container.ontouchend = (e) => {
                e.preventDefault();
                if (!game2048TouchStartX || !game2048TouchStartY) return;

                const touch = e.changedTouches[0];
                const diffX = game2048TouchStartX - touch.clientX;
                const diffY = game2048TouchStartY - touch.clientY;

                if (Math.abs(diffX) > Math.abs(diffY)) {
                    if (diffX > 30) {
                        if (move2048Left()) {
                            addRandomTile();
                            render2048();
                        }
                    } else if (diffX < -30) {
                        if (move2048Right()) {
                            addRandomTile();
                            render2048();
                        }
                    }
                } else {
                    if (diffY > 30) {
                        if (move2048Up()) {
                            addRandomTile();
                            render2048();
                        }
                    } else if (diffY < -30) {
                        if (move2048Down()) {
                            addRandomTile();
                            render2048();
                        }
                    }
                }

                game2048TouchStartX = 0;
                game2048TouchStartY = 0;
            };

            document.onkeydown = (e) => {
                if (currentGame !== 'game-2048') return;
                
                let moved = false;
                const key = e.key.toLowerCase();
                
                if (key === 'arrowup' || key === 'w') {
                    moved = move2048Up();
                } else if (key === 'arrowdown' || key === 's') {
                    moved = move2048Down();
                } else if (key === 'arrowleft' || key === 'a') {
                    moved = move2048Left();
                } else if (key === 'arrowright' || key === 'd') {
                    moved = move2048Right();
                }
                
                if (moved) {
                    addRandomTile();
                    render2048();
                }
            };
        }

        function addRandomTile() {
            const emptyCells = [];
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (game2048Board[i][j] === 0) {
                        emptyCells.push({ row: i, col: j });
                    }
                }
            }
            
            if (emptyCells.length > 0) {
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                game2048Board[randomCell.row][randomCell.col] = Math.random() < 0.9 ? 2 : 4;
            }
        }

        function render2048() {
            const grid = document.getElementById('game-2048-grid');
            if (!grid) return;
            
            grid.innerHTML = '';
            grid.style.display = 'grid';
            grid.style.gridTemplateColumns = 'repeat(4, 60px)';
            grid.style.gap = '4px';
            
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'w-15 h-15 bg-gray-300 dark:bg-gray-600 rounded flex items-center justify-center font-bold';
                    cell.style.width = '60px';
                    cell.style.height = '60px';
                    
                    const value = game2048Board[i][j];
                    if (value > 0) {
                        cell.textContent = value;
                        cell.style.backgroundColor = getTileColor(value);
                        cell.style.color = value <= 4 ? '#776e65' : '#f9f6f2';
                    }
                    
                    grid.appendChild(cell);
                }
            }
            
            document.getElementById('game-2048-score').textContent = game2048Score;
            
            if (check2048Win()) {
                document.getElementById('game-2048-status').textContent = 'üéâ You won!';
            } else if (check2048GameOver()) {
                document.getElementById('game-2048-status').textContent = 'üòû Game Over!';
            }
        }

        function getTileColor(value) {
            const colors = {
                2: '#eee4da', 4: '#ede0c8', 8: '#f2b179', 16: '#f59563',
                32: '#f67c5f', 64: '#f65e3b', 128: '#edcf72', 256: '#edcc61',
                512: '#edc850', 1024: '#edc53f', 2048: '#edc22e'
            };
            return colors[value] || '#3c3a32';
        }

        function move2048Left() {
            let moved = false;
            for (let i = 0; i < 4; i++) {
                const row = game2048Board[i].filter(val => val !== 0);
                for (let j = 0; j < row.length - 1; j++) {
                    if (row[j] === row[j + 1]) {
                        row[j] *= 2;
                        game2048Score += row[j];
                        row.splice(j + 1, 1);
                    }
                }
                while (row.length < 4) row.push(0);
                
                if (JSON.stringify(row) !== JSON.stringify(game2048Board[i])) {
                    moved = true;
                    game2048Board[i] = row;
                }
            }
            return moved;
        }

        function move2048Right() {
            let moved = false;
            for (let i = 0; i < 4; i++) {
                const row = game2048Board[i].filter(val => val !== 0);
                for (let j = row.length - 1; j > 0; j--) {
                    if (row[j] === row[j - 1]) {
                        row[j] *= 2;
                        game2048Score += row[j];
                        row.splice(j - 1, 1);
                        j--;
                    }
                }
                while (row.length < 4) row.unshift(0);
                
                if (JSON.stringify(row) !== JSON.stringify(game2048Board[i])) {
                    moved = true;
                    game2048Board[i] = row;
                }
            }
            return moved;
        }

        function move2048Up() {
            let moved = false;
            for (let j = 0; j < 4; j++) {
                const col = [];
                for (let i = 0; i < 4; i++) {
                    if (game2048Board[i][j] !== 0) col.push(game2048Board[i][j]);
                }
                
                for (let i = 0; i < col.length - 1; i++) {
                    if (col[i] === col[i + 1]) {
                        col[i] *= 2;
                        game2048Score += col[i];
                        col.splice(i + 1, 1);
                    }
                }
                while (col.length < 4) col.push(0);
                
                for (let i = 0; i < 4; i++) {
                    if (game2048Board[i][j] !== col[i]) {
                        moved = true;
                        game2048Board[i][j] = col[i];
                    }
                }
            }
            return moved;
        }

        function move2048Down() {
            let moved = false;
            for (let j = 0; j < 4; j++) {
                const col = [];
                for (let i = 0; i < 4; i++) {
                    if (game2048Board[i][j] !== 0) col.push(game2048Board[i][j]);
                }
                
                for (let i = col.length - 1; i > 0; i--) {
                    if (col[i] === col[i - 1]) {
                        col[i] *= 2;
                        game2048Score += col[i];
                        col.splice(i - 1, 1);
                        i--;
                    }
                }
                while (col.length < 4) col.unshift(0);
                
                for (let i = 0; i < 4; i++) {
                    if (game2048Board[i][j] !== col[i]) {
                        moved = true;
                        game2048Board[i][j] = col[i];
                    }
                }
            }
            return moved;
        }

        function check2048Win() {
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (game2048Board[i][j] === 2048) return true;
                }
            }
            return false;
        }

        function check2048GameOver() {
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (game2048Board[i][j] === 0) return false;
                }
            }
            
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 3; j++) {
                    if (game2048Board[i][j] === game2048Board[i][j + 1]) return false;
                    if (game2048Board[j][i] === game2048Board[j + 1][i]) return false;
                }
            }
            
            return true;
        }

        function restart2048() {
            init2048();
            document.getElementById('game-2048-status').textContent = '';
        }

        // Memory Match Game
        const cardEmojis = ['üê±', 'üê∂', 'üêº', 'ü¶ä', 'üê®', 'üê∞', 'üê∏', 'üêØ'];
        let memoryCards = [];
        let flippedCards = [];
        let moves = 0;
        let matches = 0;

        function resetMemoryGame() {
            const grid = document.getElementById('memory-grid');
            if (!grid) return;
            
            const shuffled = [...cardEmojis, ...cardEmojis].sort(() => Math.random() - 0.5);
            
            memoryCards = shuffled.map((emoji, index) => ({
                id: index,
                emoji: emoji,
                flipped: false,
                matched: false
            }));

            flippedCards = [];
            moves = 0;
            matches = 0;
            
            updateMemoryCounters();
            
            grid.innerHTML = memoryCards.map(card => `
                <div class="memory-card w-16 h-16 cursor-pointer" onclick="flipCard(${card.id})">
                    <div class="memory-card-inner relative w-full h-full">
                        <div class="memory-card-front absolute inset-0 bg-primary rounded-lg flex items-center justify-center">
                            <span class="text-white text-xl">?</span>
                        </div>
                        <div class="memory-card-back absolute inset-0 bg-white dark:bg-gray-700 border-2 border-gray-300 dark:border-gray-600 rounded-lg flex items-center justify-center">
                            <span class="text-2xl">${card.emoji}</span>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function flipCard(cardId) {
            if (flippedCards.length >= 2 || memoryCards[cardId].flipped || memoryCards[cardId].matched) return;

            memoryCards[cardId].flipped = true;
            flippedCards.push(cardId);
            
            const cardElement = document.querySelectorAll('.memory-card')[cardId];
            cardElement.classList.add('flipped');

            if (flippedCards.length === 2) {
                moves++;
                updateMemoryCounters();
                
                setTimeout(() => {
                    checkMatch();
                }, 1000);
            }
        }

        function checkMatch() {
            const [first, second] = flippedCards;
            
            if (memoryCards[first].emoji === memoryCards[second].emoji) {
                memoryCards[first].matched = true;
                memoryCards[second].matched = true;
                matches++;
                
                if (matches === 8) {
                    setTimeout(() => {
                        alert(`üéâ Congratulations! You won in ${moves} moves!`);
                    }, 500);
                }
            } else {
                memoryCards[first].flipped = false;
                memoryCards[second].flipped = false;
                
                const cardElements = document.querySelectorAll('.memory-card');
                cardElements[first].classList.remove('flipped');
                cardElements[second].classList.remove('flipped');
            }
            
            flippedCards = [];
            updateMemoryCounters();
        }

        function updateMemoryCounters() {
            document.getElementById('move-counter').textContent = moves;
            document.getElementById('match-counter').textContent = matches;
        }

        // Reaction Time Game
        let reactionStartTime;
        let reactionTimeout;
        let waitingForReaction = false;

        function startReactionTest() {
            const area = document.getElementById('reaction-area');
            const text = document.getElementById('reaction-text');
            const startBtn = document.getElementById('reaction-start-btn');
            
            area.className = 'w-full max-w-md mx-auto h-64 bg-red-500 rounded-lg flex items-center justify-center mb-6 cursor-pointer transition-colors';
            text.textContent = 'Wait for green...';
            startBtn.style.display = 'none';
            document.getElementById('reaction-result').textContent = '';
            waitingForReaction = false;
            currentGameRunning = true;
            updateMobileButton();
            
            const delay = Math.random() * 4000 + 1000;
            
            reactionTimeout = setTimeout(() => {
                area.className = 'w-full max-w-md mx-auto h-64 bg-green-500 rounded-lg flex items-center justify-center mb-6 cursor-pointer transition-colors';
                text.textContent = 'TAP NOW!';
                reactionStartTime = Date.now();
                waitingForReaction = true;
            }, delay);
        }

        function handleReactionClick() {
            if (!reactionStartTime && !waitingForReaction) return;
            
            const area = document.getElementById('reaction-area');
            const text = document.getElementById('reaction-text');
            const startBtn = document.getElementById('reaction-start-btn');
            const result = document.getElementById('reaction-result');
            
            if (!waitingForReaction) {
                clearTimeout(reactionTimeout);
                area.className = 'w-full max-w-md mx-auto h-64 bg-red-500 rounded-lg flex items-center justify-center mb-6 cursor-pointer transition-colors';
                text.textContent = 'Too early! Try again.';
                startBtn.style.display = 'inline-block';
                result.textContent = '';
                currentGameRunning = false;
                updateMobileButton();
                return;
            }
            
            const reactionTime = Date.now() - reactionStartTime;
            
            area.className = 'w-full max-w-md mx-auto h-64 bg-gray-300 dark:bg-gray-700 rounded-lg flex items-center justify-center mb-6 cursor-pointer transition-colors';
            text.textContent = 'Tap "Start" to try again';
            startBtn.style.display = 'inline-block';
            result.textContent = `Reaction time: ${reactionTime}ms`;
            
            waitingForReaction = false;
            reactionStartTime = null;
            currentGameRunning = false;
            updateMobileButton();
        }

        function resetReactionTest() {
            const area = document.getElementById('reaction-area');
            const text = document.getElementById('reaction-text');
            const startBtn = document.getElementById('reaction-start-btn');
            
            clearTimeout(reactionTimeout);
            area.className = 'w-full max-w-md mx-auto h-64 bg-gray-300 dark:bg-gray-700 rounded-lg flex items-center justify-center mb-6 cursor-pointer transition-colors';
            text.textContent = 'Tap "Start" to begin';
            startBtn.style.display = 'inline-block';
            document.getElementById('reaction-result').textContent = '';
            waitingForReaction = false;
            reactionStartTime = null;
            currentGameRunning = false;
        }

        // Click Accuracy Game
        let accuracyGameRunning = false;
        let accuracyScore = 0;
        let accuracyTimeLeft = 30;

        function startAccuracyGame() {
            if (accuracyGameRunning) return;
            
            accuracyGameRunning = true;
            currentGameRunning = true;
            accuracyScore = 0;
            accuracyTimeLeft = 30;
            updateMobileButton();
            
            const gameArea = document.getElementById('accuracy-game-area');
            gameArea.innerHTML = '';
            
            const timer = setInterval(() => {
                accuracyTimeLeft--;
                document.getElementById('accuracy-time').textContent = accuracyTimeLeft + 's';
                
                if (accuracyTimeLeft <= 0) {
                    clearInterval(timer);
                    accuracyGameRunning = false;
                    currentGameRunning = false;
                    updateMobileButton();
                    alert(`Game Over! Final Score: ${accuracyScore}`);
                    return;
                }
                
                if (Math.random() < 0.6) {
                    spawnTarget();
                }
            }, 1000);
            
            updateAccuracyStats();
        }

        function spawnTarget() {
            const gameArea = document.getElementById('accuracy-game-area');
            const target = document.createElement('div');
            target.className = 'absolute w-12 h-12 bg-red-500 rounded-full cursor-pointer';
            target.style.left = Math.random() * (gameArea.offsetWidth - 48) + 'px';
            target.style.top = Math.random() * (gameArea.offsetHeight - 48) + 'px';
            
            target.onclick = () => {
                accuracyScore += 10;
                target.remove();
                updateAccuracyStats();
            };
            
            gameArea.appendChild(target);
            
            setTimeout(() => {
                if (target.parentNode) {
                    target.remove();
                }
            }, 2000);
        }

        function updateAccuracyStats() {
            document.getElementById('accuracy-score').textContent = accuracyScore;
        }

        function resetAccuracyGame() {
            accuracyGameRunning = false;
            currentGameRunning = false;
            accuracyScore = 0;
            accuracyTimeLeft = 30;
            
            document.getElementById('accuracy-score').textContent = '0';
            document.getElementById('accuracy-time').textContent = '30s';
            document.getElementById('accuracy-game-area').innerHTML = '';
        }

        // Flappy Bird
        let flappyCanvas, flappyCtx;
        let flappyBird, flappyPipes, flappyScore, flappyBest;
        let flappyGameRunning = false;

        function setupFlappyBird() {
            flappyCanvas = document.getElementById('flappy-canvas');
            if (!flappyCanvas) return;
            
            flappyCtx = flappyCanvas.getContext('2d');
            
            try {
                flappyBest = parseInt(localStorage.getItem('flappyBest')) || 0;
            } catch (error) {
                flappyBest = 0;
            }
            document.getElementById('flappy-best').textContent = flappyBest;
            
            initFlappyBird();
            
            // Touch and key events
            flappyCanvas.onclick = flapBird;
            flappyCanvas.ontouchstart = (e) => {
                e.preventDefault();
                flapBird();
            };
            
            document.onkeydown = (e) => {
                if (currentGame === 'flappy-bird' && e.code === 'Space') {
                    e.preventDefault();
                    flapBird();
                }
            };
        }

        function initFlappyBird() {
            flappyBird = { x: 80, y: 240, velocity: 0, size: 20 };
            flappyPipes = [];
            flappyScore = 0;
            flappyGameRunning = false;
            currentGameRunning = false;
            updateFlappyScore();
            drawFlappyBird();
        }

        function startFlappyBird() {
            if (flappyGameRunning) return;
            flappyGameRunning = true;
            currentGameRunning = true;
            updateMobileButton();
            document.getElementById('flappy-status').textContent = '';
            flappyGameLoop();
        }

        function flapBird() {
            if (flappyGameRunning) {
                flappyBird.velocity = -8;
            }
        }

        function flappyGameLoop() {
            if (!flappyGameRunning) return;
            
            updateFlappyBird();
            drawFlappyBird();
            
            requestAnimationFrame(flappyGameLoop);
        }

        function updateFlappyBird() {
            flappyBird.velocity += 0.5;
            flappyBird.y += flappyBird.velocity;
            
            if (flappyBird.y <= 0 || flappyBird.y >= 460) {
                endFlappyGame();
                return;
            }
            
            if (flappyPipes.length === 0 || flappyPipes[flappyPipes.length - 1].x < 200) {
                const gapY = Math.random() * 200 + 100;
                flappyPipes.push({
                    x: 320,
                    topHeight: gapY - 60,
                    bottomY: gapY + 60,
                    scored: false
                });
            }
            
            flappyPipes.forEach(pipe => {
                pipe.x -= 2;
                
                if (!pipe.scored && pipe.x + 30 < flappyBird.x) {
                    pipe.scored = true;
                    flappyScore++;
                    updateFlappyScore();
                }
                
                if (flappyBird.x + flappyBird.size > pipe.x && flappyBird.x < pipe.x + 30) {
                    if (flappyBird.y < pipe.topHeight || flappyBird.y + flappyBird.size > pipe.bottomY) {
                        endFlappyGame();
                        return;
                    }
                }
            });
            
            flappyPipes = flappyPipes.filter(pipe => pipe.x > -30);
        }

        function drawFlappyBird() {
            flappyCtx.clearRect(0, 0, flappyCanvas.width, flappyCanvas.height);
            
            flappyCtx.fillStyle = '#87CEEB';
            flappyCtx.fillRect(0, 0, flappyCanvas.width, flappyCanvas.height);
            
            flappyCtx.fillStyle = '#F59E0B';
            flappyCtx.fillRect(flappyBird.x, flappyBird.y, flappyBird.size, flappyBird.size);
            
            flappyCtx.fillStyle = '#10B981';
            flappyPipes.forEach(pipe => {
                flappyCtx.fillRect(pipe.x, 0, 30, pipe.topHeight);
                flappyCtx.fillRect(pipe.x, pipe.bottomY, 30, 480 - pipe.bottomY);
            });
        }

        function endFlappyGame() {
            flappyGameRunning = false;
            currentGameRunning = false;
            updateMobileButton();
            
            if (flappyScore > flappyBest) {
                flappyBest = flappyScore;
                try {
                    localStorage.setItem('flappyBest', flappyBest.toString());
                } catch (error) {}
                document.getElementById('flappy-best').textContent = flappyBest;
                document.getElementById('flappy-status').textContent = 'üéâ New Best Score!';
            } else {
                document.getElementById('flappy-status').textContent = 'Game Over! Tap Start to play again.';
            }
        }

        function updateFlappyScore() {
            document.getElementById('flappy-score').textContent = flappyScore;
        }

        // Pixel Art (36x36 grid)
        let pixelGrid = [];
        let currentPixelColor = '#000000';

        function setupPixelArt() {
            const gridSize = 20; // Smaller for mobile
            const container = document.getElementById('pixel-grid');
            pixelGrid = [];
            
            container.innerHTML = '';
            container.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
            
            for (let i = 0; i < gridSize * gridSize; i++) {
                const cell = document.createElement('div');
                cell.className = 'pixel-cell bg-white';
                cell.onclick = () => paintPixel(i);
                container.appendChild(cell);
                pixelGrid.push('#ffffff');
            }
        }

        function setPixelColor(color) {
            currentPixelColor = color;
        }

        function paintPixel(index) {
            pixelGrid[index] = currentPixelColor;
            const cells = document.querySelectorAll('.pixel-cell');
            cells[index].style.backgroundColor = currentPixelColor;
        }

        function clearPixelArt() {
            const cells = document.querySelectorAll('.pixel-cell');
            cells.forEach(cell => {
                cell.style.backgroundColor = '#ffffff';
            });
            pixelGrid.fill('#ffffff');
        }

        // Simple Sudoku
        let sudokuBoard = [];
        let selectedSudokuCell = null;

        function generateSudoku() {
            const difficulty = document.getElementById('sudoku-difficulty').value;
            const clues = difficulty === 'easy' ? 35 : difficulty === 'medium' ? 25 : 20;
            
            // Generate a simple 9x9 grid with some numbers
            sudokuBoard = Array(9).fill().map(() => Array(9).fill(0));
            
            // Add some random numbers (simplified approach)
            for (let i = 0; i < clues; i++) {
                const row = Math.floor(Math.random() * 9);
                const col = Math.floor(Math.random() * 9);
                const num = Math.floor(Math.random() * 9) + 1;
                if (sudokuBoard[row][col] === 0) {
                    sudokuBoard[row][col] = num;
                }
            }
            
            renderSudoku();
        }

        function renderSudoku() {
            const grid = document.getElementById('sudoku-grid');
            grid.innerHTML = '';
            grid.style.display = 'grid';
            grid.style.gridTemplateColumns = 'repeat(9, 1fr)';
            grid.style.gap = '1px';
            grid.style.maxWidth = '300px';
            
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    const cell = document.createElement('input');
                    cell.className = 'w-8 h-8 text-center border text-sm font-bold';
                    cell.type = 'number';
                    cell.min = '1';
                    cell.max = '9';
                    
                    if (sudokuBoard[i][j] !== 0) {
                        cell.value = sudokuBoard[i][j];
                        cell.readOnly = true;
                        cell.style.backgroundColor = '#f3f4f6';
                    }
                    
                    grid.appendChild(cell);
                }
            }
            
            // Generate number buttons
            const numbersContainer = document.getElementById('sudoku-numbers');
            numbersContainer.innerHTML = '';
            for (let i = 1; i <= 9; i++) {
                const btn = document.createElement('button');
                btn.className = 'px-3 py-2 bg-primary hover:bg-primary-dark text-white rounded text-sm';
                btn.textContent = i;
                numbersContainer.appendChild(btn);
            }
        }

        // Enhanced Typing Challenge System
        let typingStartTime;
        let typingText = '';
        let typingInterval;
        let typingDuration = 60; // seconds
        let currentTypingChallenge = 'words';
        let typingTestActive = false;
        let typingErrors = 0;
        let typingCharsTyped = 0;

        // Text databases for different challenges
        const typingChallenges = {
            words: {
                name: 'Common Words',
                texts: [
                    "the quick brown fox jumps over the lazy dog",
                    "pack my box with five dozen liquor jugs",
                    "how vexingly quick daft zebras jump",
                    "bright vixens jump doggedly",
                    "sphinx of black quartz judge my vow",
                    "jackdaws love my big sphinx of quartz",
                    "crazy frederick bought many very exquisite opal jewels",
                    "we promptly judged antique ivory buckles for the next prize",
                    "a mad boxer shot a quick gloved jab to the jaw of his dizzy opponent",
                    "jaded zombies acted quaintly but kept driving their oxen forward"
                ]
            },
            quotes: {
                name: 'Famous Quotes',
                texts: [
                    "The only way to do great work is to love what you do. - Steve Jobs",
                    "Life is what happens to you while you're busy making other plans. - John Lennon",
                    "The future belongs to those who believe in the beauty of their dreams. - Eleanor Roosevelt",
                    "It is during our darkest moments that we must focus to see the light. - Aristotle",
                    "The only impossible journey is the one you never begin. - Tony Robbins",
                    "In the end, we will remember not the words of our enemies, but the silence of our friends. - Martin Luther King Jr.",
                    "The only thing we have to fear is fear itself. - Franklin D. Roosevelt",
                    "Darkness cannot drive out darkness; only light can do that. - Martin Luther King Jr.",
                    "Be yourself; everyone else is already taken. - Oscar Wilde",
                    "Two things are infinite: the universe and human stupidity; and I'm not sure about the universe. - Albert Einstein"
                ]
            },
            code: {
                name: 'Code Snippets',
                texts: [
                    "function calculateSum(a, b) { return a + b; }",
                    "const array = [1, 2, 3, 4, 5]; array.map(x => x * 2);",
                    "if (condition === true) { console.log('Hello World'); }",
                    "for (let i = 0; i < array.length; i++) { sum += array[i]; }",
                    "const obj = { name: 'John', age: 30, city: 'New York' };",
                    "document.getElementById('element').addEventListener('click', handler);",
                    "try { JSON.parse(data); } catch (error) { console.error(error); }",
                    "class Rectangle { constructor(width, height) { this.width = width; } }",
                    "const promise = new Promise((resolve, reject) => { resolve('Success'); });",
                    "import React from 'react'; export default function Component() { return <div>Hello</div>; }"
                ]
            },
            numbers: {
                name: 'Numbers',
                texts: [
                    "1234567890 9876543210 1357924680 2468013579",
                    "3.14159 2.71828 1.41421 1.61803 0.57721 2.30258",
                    "100 200 300 400 500 600 700 800 900 1000",
                    "42 73 108 256 512 1024 2048 4096 8192 16384",
                    "987654321 123456789 555666777 888999000 111222333",
                    "2023 2024 2025 1995 1999 2000 2010 2015 2020",
                    "50% 75% 25% 90% 10% 33% 66% 80% 20% 95%",
                    "1st 2nd 3rd 4th 5th 6th 7th 8th 9th 10th",
                    "$1,234.56 $9,876.54 $555.00 $1,000,000.00 $99.99",
                    "1/2 1/3 1/4 2/3 3/4 5/8 7/8 3/5 4/5 9/10"
                ]
            },
            punctuation: {
                name: 'Punctuation',
                texts: [
                    "Hello, world! How are you? I'm fine, thanks. What's new?",
                    "Don't stop; keep going! You're doing great, aren't you?",
                    "The cat's pajamas, the bee's knees, and the dog's breakfast.",
                    "It's raining cats & dogs outside (literally speaking).",
                    "I said, \"Hello!\" but she replied, \"Goodbye...\"",
                    "The items are: apples, oranges, bananas; and grapes.",
                    "Question: What time is it? Answer: It's 3:30 P.M.",
                    "E-mail: user@example.com; Website: https://example.com",
                    "Math: 2 + 2 = 4; 3 * 3 = 9; 10 / 2 = 5; 5 - 1 = 4.",
                    "Contractions: can't, won't, shouldn't, haven't, isn't."
                ]
            },
            mixed: {
                name: 'Mixed Challenge',
                texts: [
                    "In 2023, we analyzed 1,000+ datasets using Python & R programming languages.",
                    "The function f(x) = x^2 + 3x - 5 has roots at x = -5 and x = 1.",
                    "ERROR 404: Page not found! Please check the URL: https://example.com/page",
                    "Database query: SELECT * FROM users WHERE age > 18 AND status = 'active';",
                    "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt.",
                    "The API returned JSON: {\"status\": \"success\", \"data\": [1, 2, 3]}",
                    "CSS: .container { display: flex; justify-content: center; align-items: center; }",
                    "Regular expression: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/",
                    "Machine learning model achieved 95.7% accuracy on the test dataset (n=10,000).",
                    "Git command: git commit -m \"Fix bug #123: Update user authentication module\""
                ]
            },
            speed: {
                name: 'Speed Burst',
                texts: [
                    "a s d f g h j k l",
                    "the and for are but not you all with can had her was one our out day get use man new now way may say each which she how its they them been has said many would what were like time very when much here more into just over think also back after first well year work where his good between without should through make before right too under these never because being does being why then than still more most long small great little home little right still another away turn both every nothing something again though three very place might while against another right off use where give would take",
                    "cat dog rat bat hat mat sat fat pat rat",
                    "123 456 789 000 111 222 333 444 555 666 777 888 999",
                    "quick brown fox lazy dog",
                    "abcd efgh ijkl mnop qrst uvwx yz",
                    "!!!! ???? .... ,,,, ;;;; ::::",
                    "fast type test speed quick rapid swift fleet hasty",
                    "1a 2b 3c 4d 5e 6f 7g 8h 9i 0j",
                    "go go go fast fast fast type type type now now now"
                ]
            },
            accuracy: {
                name: 'Accuracy Test',
                texts: [
                    "precision requires careful attention to every single detail and character",
                    "accommodate, beginning, calendar, definitely, embarrass, foreign, guarantee",
                    "immediately, knowledge, library, maintenance, necessary, occurrence, privilege",
                    "questionnaire, restaurant, separate, tomorrow, unnecessary, vacuum, weird",
                    "beautiful, business, celebrate, computer, different, environment, favorite",
                    "government, hospital, important, language, medicine, necessary, opportunity",
                    "people, question, remember, something, together, understand, weather",
                    "accommodate separate privilege questionnaire occurrence embarrass foreign",
                    "distinguish miscellaneous manoeuvre bureaucracy chrysanthemum onomatopoeia",
                    "antidisestablishmentarianism pseudopseudohypoparathyroidism supercalifragilisticexpialidocious"
                ]
            }
        };

        function setTypingChallenge(challenge) {
            currentTypingChallenge = challenge;
            
            // Update button appearance
            document.querySelectorAll('.typing-challenge-btn').forEach(btn => {
                btn.classList.remove('ring-2', 'ring-white');
            });
            event.target.classList.add('ring-2', 'ring-white');
            
            // Update current challenge display
            document.getElementById('current-challenge').textContent = typingChallenges[challenge].name;
            
            // Generate new text for the challenge
            generateTypingText();
        }

        function generateTypingText() {
            const challengeData = typingChallenges[currentTypingChallenge];
            const selectedTexts = challengeData.texts;
            
            if (currentTypingChallenge === 'speed') {
                // For speed challenge, use shorter, repetitive text
                typingText = selectedTexts[Math.floor(Math.random() * selectedTexts.length)];
            } else {
                // For other challenges, combine multiple texts
                const numTexts = Math.min(3, selectedTexts.length);
                const shuffled = [...selectedTexts].sort(() => Math.random() - 0.5);
                typingText = shuffled.slice(0, numTexts).join(' ');
            }
            
            document.getElementById('text-to-type').textContent = typingText;
        }

        function startTypingTest() {
            if (typingTestActive) return;
            
            typingDuration = parseInt(document.getElementById('typing-duration').value);
            generateTypingText();
            
            typingTestActive = true;
            typingStartTime = Date.now();
            typingErrors = 0;
            typingCharsTyped = 0;
            
            document.getElementById('typing-input').value = '';
            document.getElementById('typing-input').disabled = false;
            document.getElementById('typing-input').focus();
            document.getElementById('typing-results').classList.add('hidden');
            
            // Start the timer
            typingInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - typingStartTime) / 1000);
                const remaining = Math.max(0, typingDuration - elapsed);
                
                document.getElementById('time-display').textContent = remaining + 's';
                
                if (remaining <= 0) {
                    endTypingTest();
                }
                
                updateTypingStats();
            }, 100);
            
            updateTypingStats();
        }

        function resetTypingTest() {
            endTypingTest();
            document.getElementById('typing-input').value = '';
            document.getElementById('typing-results').classList.add('hidden');
            generateTypingText();
        }

        function endTypingTest() {
            if (!typingTestActive) return;
            
            typingTestActive = false;
            clearInterval(typingInterval);
            document.getElementById('typing-input').disabled = true;
            
            // Calculate final stats
            const finalStats = calculateTypingStats();
            showTypingResults(finalStats);
        }

        function handleTypingInput() {
            if (!typingTestActive) return;
            
            const input = document.getElementById('typing-input').value;
            
            // Count errors and characters
            typingCharsTyped = input.length;
            typingErrors = 0;
            
            for (let i = 0; i < input.length; i++) {
                if (i >= typingText.length || input[i] !== typingText[i]) {
                    typingErrors++;
                }
            }
            
            updateTypingStats();
            
            // Check for completion
            if (input === typingText) {
                endTypingTest();
            }
        }

        function calculateTypingStats() {
            const timeElapsed = (Date.now() - typingStartTime) / 1000;
            const wordsTyped = typingCharsTyped / 5;
            const wpm = Math.round((wordsTyped / timeElapsed) * 60);
            const accuracy = typingCharsTyped > 0 ? Math.round(((typingCharsTyped - typingErrors) / typingCharsTyped) * 100) : 100;
            
            return {
                wpm: Math.max(0, wpm),
                accuracy: Math.max(0, accuracy),
                time: Math.round(timeElapsed),
                chars: typingCharsTyped,
                errors: typingErrors
            };
        }

        function updateTypingStats() {
            if (!typingTestActive) return;
            
            const stats = calculateTypingStats();
            
            document.getElementById('wpm-display').textContent = stats.wpm;
            document.getElementById('accuracy-display').textContent = stats.accuracy + '%';
        }

        function showTypingResults(stats) {
            document.getElementById('final-wpm').textContent = stats.wpm;
            document.getElementById('final-accuracy').textContent = stats.accuracy + '%';
            document.getElementById('final-chars').textContent = stats.chars;
            document.getElementById('final-errors').textContent = stats.errors;
            
            // Performance rating
            let rating = '';
            let tips = '';
            
            if (stats.wpm >= 80 && stats.accuracy >= 95) {
                rating = 'üèÜ Master Typist!';
                tips = 'Outstanding! You type faster than 99% of people.';
            } else if (stats.wpm >= 60 && stats.accuracy >= 90) {
                rating = '‚≠ê Expert Level!';
                tips = 'Excellent typing skills! Keep it up.';
            } else if (stats.wpm >= 40 && stats.accuracy >= 85) {
                rating = 'üëç Good Typist';
                tips = 'Good speed and accuracy. Practice for even better results.';
            } else if (stats.wpm >= 25 && stats.accuracy >= 80) {
                rating = 'üìà Improving';
                tips = 'You\'re getting better! Focus on accuracy first, then speed.';
            } else {
                rating = 'üå± Keep Practicing';
                tips = 'Practice regularly to improve. Try easier challenges first.';
            }
            
            document.getElementById('performance-rating').textContent = rating;
            document.getElementById('performance-tips').textContent = tips;
            
            document.getElementById('typing-results').classList.remove('hidden');
        }

        // Initialize with default challenge
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                if (currentGame === 'typing-speed') {
                    setTypingChallenge('words');
                }
            }, 200);
        });

        // Tower Defense Game - Fixed Version
let tdCanvas, tdCtx;
let tdMoney = 100;
let tdLives = 20;
let tdWave = 1;
let tdScore = 0;
let tdGameRunning = false;
let selectedTowerType = 'basic';
let sellModeActive = false;

// Wave management - FIXED
let waveActive = false;
let waveSpawning = false;
let enemiesToSpawn = 0;
let enemiesSpawned = 0;
let lastSpawnTime = 0;
let waveCompleteTime = 0;

// Game objects
let towers = [];
let enemies = [];
let projectiles = [];
let path = [];

// Tower types
const towerTypes = {
    basic: { cost: 20, damage: 15, range: 80, fireRate: 1000, color: '#3B82F6', size: 15 },
    heavy: { cost: 50, damage: 40, range: 70, fireRate: 1500, color: '#EF4444', size: 18 },
    rapid: { cost: 35, damage: 8, range: 90, fireRate: 400, color: '#10B981', size: 12 }
};

// Enemy types
const enemyTypes = {
    basic: { hp: 30, speed: 1, reward: 10, color: '#F59E0B', size: 8 },
    fast: { hp: 20, speed: 2, reward: 15, color: '#8B5CF6', size: 6 },
    tank: { hp: 80, speed: 0.5, reward: 25, color: '#6B7280', size: 12 }
};
// 8 Different Map Layouts
const mapLayouts = {
    1: { name: "Gentle Waves", description: "A smooth wavy path" },
    2: { name: "Sharp Turns", description: "Quick zigzag movements" },
    3: { name: "The Spiral", description: "Enemies spiral inward" },
    4: { name: "Double Bend", description: "Two major direction changes" },
    5: { name: "Mountain Pass", description: "Up and down terrain" },
    6: { name: "The Maze", description: "Complex winding path" },
    7: { name: "Speed Track", description: "Mostly straight with curves" },
    8: { name: "Loop-de-Loop", description: "Figure-8 style path" }
};

let currentMapId = 1;
        
function setupTowerDefense() {
    tdCanvas = document.getElementById('td-canvas');
    if (!tdCanvas) return;
    
    tdCtx = tdCanvas.getContext('2d');
    
    // Create the path (simple S-curve)
    createPath();
    
    // Canvas click handler
    tdCanvas.onclick = handleTDClick;
    tdCanvas.ontouchstart = (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = tdCanvas.getBoundingClientRect();
        const x = (touch.clientX - rect.left) * (tdCanvas.width / rect.width);
        const y = (touch.clientY - rect.top) * (tdCanvas.height / rect.height);
        handleTDClickAt(x, y);
    };
    
    resetTowerDefense();
}
function generateNewMap() {
    // Only allow map change when no wave is active
    if (waveActive || waveSpawning) {
        document.getElementById('td-status').textContent = 'Cannot change map during active wave!';
        return;
    }
    
    // Clear current enemies and projectiles
    enemies = [];
    projectiles = [];
    
    // Generate new path
    createPath();
    drawTowerDefense();
}

function createPath() {
    // Randomly select a map (1-8)
    currentMapId = Math.floor(Math.random() * 8) + 1;
    path = [];
    
    const width = tdCanvas.width;
    const height = tdCanvas.height;
    
    switch(currentMapId) {
        case 1: // Gentle Waves
            for (let x = 0; x <= width; x += 5) {
                let y = height/2 + Math.sin(x * 0.008) * 60;
                path.push({ x, y });
            }
            break;
            
        case 2: // Sharp Turns (Zigzag)
            let zigzagY = height/2;
            let direction = 1;
            for (let x = 0; x <= width; x += 10) {
                if (x % 100 === 0 && x > 0) {
                    direction *= -1;
                }
                zigzagY += direction * 3;
                zigzagY = Math.max(50, Math.min(height-50, zigzagY));
                path.push({ x, y: zigzagY });
            }
            break;
            
        case 3: // The Spiral
            const centerX = width/2;
            const centerY = height/2;
            let angle = 0;
            let radius = 120;
            
            // Start from outside and spiral in
            for (let i = 0; i < 200; i++) {
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                path.push({ x, y });
                angle += 0.08;
                radius = Math.max(20, radius - 0.6);
            }
            break;
            
        case 4: // Double Bend
            const segments = [
                { start: 0, end: width*0.3, startY: height*0.8, endY: height*0.2 },
                { start: width*0.3, end: width*0.7, startY: height*0.2, endY: height*0.2 },
                { start: width*0.7, end: width, startY: height*0.2, endY: height*0.8 }
            ];
            
            segments.forEach(segment => {
                const segmentWidth = segment.end - segment.start;
                for (let x = segment.start; x <= segment.end; x += 5) {
                    const progress = (x - segment.start) / segmentWidth;
                    const y = segment.startY + (segment.endY - segment.startY) * progress;
                    path.push({ x, y });
                }
            });
            break;
            
        case 5: // Mountain Pass (Up and Down)
            for (let x = 0; x <= width; x += 5) {
                let y = height/2 + Math.sin(x * 0.02) * 80 + Math.cos(x * 0.015) * 40;
                y = Math.max(50, Math.min(height-50, y));
                path.push({ x, y });
            }
            break;
            
        case 6: // The Maze (Complex winding)
            const waypoints = [
                { x: 0, y: height*0.7 },
                { x: width*0.2, y: height*0.7 },
                { x: width*0.2, y: height*0.3 },
                { x: width*0.5, y: height*0.3 },
                { x: width*0.5, y: height*0.8 },
                { x: width*0.8, y: height*0.8 },
                { x: width*0.8, y: height*0.2 },
                { x: width, y: height*0.2 }
            ];
            
            for (let i = 0; i < waypoints.length - 1; i++) {
                const start = waypoints[i];
                const end = waypoints[i + 1];
                const steps = 20;
                
                for (let step = 0; step <= steps; step++) {
                    const progress = step / steps;
                    const x = start.x + (end.x - start.x) * progress;
                    const y = start.y + (end.y - start.y) * progress;
                    path.push({ x, y });
                }
            }
            break;
            
        case 7: // Speed Track (Mostly straight)
            for (let x = 0; x <= width; x += 5) {
                let y = height/2;
                // Add slight curves at specific points
                if (x > width*0.2 && x < width*0.4) {
                    y += Math.sin((x - width*0.2) / (width*0.2) * Math.PI) * 30;
                }
                if (x > width*0.6 && x < width*0.8) {
                    y -= Math.sin((x - width*0.6) / (width*0.2) * Math.PI) * 30;
                }
                path.push({ x, y });
            }
            break;
            
        case 8: // Loop-de-Loop (Figure-8)
            const loopCenterY = height/2;
            const loopRadius = 60;
            
            // First half - top loop
            for (let x = 0; x <= width/2; x += 5) {
                const progress = (x / (width/2)) * Math.PI;
                const y = loopCenterY - Math.sin(progress) * loopRadius;
                path.push({ x, y });
            }
            
            // Second half - bottom loop
            for (let x = width/2; x <= width; x += 5) {
                const progress = ((x - width/2) / (width/2)) * Math.PI;
                const y = loopCenterY + Math.sin(progress) * loopRadius;
                path.push({ x, y });
            }
            break;
    }
    
    // Ensure path has enough points and is properly connected
    if (path.length < 10) {
        // Fallback to simple path if generation failed
        createSimplePath();
    }
    
    // Display current map info
    updateMapDisplay();
}

function createSimplePath() {
    path = [];
    for (let x = 0; x <= tdCanvas.width; x += 5) {
        path.push({ x, y: tdCanvas.height/2 });
    }
}

function updateMapDisplay() {
    const mapInfo = mapLayouts[currentMapId];
    const statusElement = document.getElementById('td-status');
    statusElement.textContent = `Map: ${mapInfo.name} - ${mapInfo.description}`;
}
function resetTowerDefense() {
    tdMoney = 100;
    tdLives = 20;
    tdWave = 1;
    tdScore = 0;
    towers = [];
    enemies = [];
    projectiles = [];
    
    // Reset wave management - FIXED
    waveActive = false;
    waveSpawning = false;
    enemiesToSpawn = 0;
    enemiesSpawned = 0;
    lastSpawnTime = 0;
    waveCompleteTime = 0;
    
    tdGameRunning = false;
    selectedTowerType = 'basic';
    sellModeActive = false;
    
    updateTDDisplay();
    updateMapDisplay();
    drawTowerDefense();
}

function selectTowerType(type) {
    selectedTowerType = type;
    sellModeActive = false;
    
    // Update button appearance
    document.querySelectorAll('[id*="tower-btn"]').forEach(btn => {
        btn.classList.remove('ring-2', 'ring-white');
    });
    document.getElementById(type + '-tower-btn').classList.add('ring-2', 'ring-white');
}

function sellMode() {
    sellModeActive = !sellModeActive;
    selectedTowerType = null;
    
    // Update button appearance
    document.querySelectorAll('[id*="tower-btn"]').forEach(btn => {
        btn.classList.remove('ring-2', 'ring-white');
    });
}

function handleTDClick(e) {
    const rect = tdCanvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (tdCanvas.width / rect.width);
    const y = (e.clientY - rect.top) * (tdCanvas.height / rect.height);
    handleTDClickAt(x, y);
}

function handleTDClickAt(x, y) {
    if (sellModeActive) {
        // Try to sell a tower
        const towerIndex = towers.findIndex(tower => {
            const dist = Math.sqrt((x - tower.x) ** 2 + (y - tower.y) ** 2);
            return dist <= tower.size;
        });
        
        if (towerIndex !== -1) {
            const tower = towers[towerIndex];
            const sellPrice = Math.floor(towerTypes[tower.type].cost * 0.5);
            tdMoney += sellPrice;
            towers.splice(towerIndex, 1);
            updateTDDisplay();
            drawTowerDefense();
        }
        return;
    }
    
    if (!selectedTowerType) return;
    
    // Check if click is on path
    const onPath = path.some(point => {
        const dist = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
        return dist <= 25;
    });
    
    if (onPath) return; // Can't build on path
    
    // Check if click is on existing tower
    const existingTower = towers.some(tower => {
        const dist = Math.sqrt((x - tower.x) ** 2 + (y - tower.y) ** 2);
        return dist <= tower.size + 10;
    });
    
    if (existingTower) return; // Can't build on existing tower
    
    // Check if player has enough money
    const towerCost = towerTypes[selectedTowerType].cost;
    if (tdMoney >= towerCost) {
        // Build tower
        const towerData = towerTypes[selectedTowerType];
        towers.push({
            x: x,
            y: y,
            type: selectedTowerType,
            lastShot: 0,
            size: towerData.size,
            ...towerData
        });
        
        tdMoney -= towerCost;
        updateTDDisplay();
        drawTowerDefense();
    }
}

function startTowerDefense() {
    // FIXED: Prevent multiple wave starts
    if (waveActive || waveSpawning) {
        document.getElementById('td-status').textContent = `Wave ${tdWave} already in progress...`;
        return;
    }
    
    if (!tdGameRunning) {
        tdGameRunning = true;
        tdGameLoop();
    }
    
    startWave();
}

// FIXED: Better wave management
function startWave() {
    if (waveActive || waveSpawning) return;
    
    waveSpawning = true;
    waveActive = true;
    enemiesSpawned = 0;
    enemiesToSpawn = Math.min(3 + tdWave * 2, 15); // Limit max enemies per wave
    lastSpawnTime = Date.now();
    
    document.getElementById('td-status').textContent = `Wave ${tdWave}: ${enemiesToSpawn} enemies incoming!`;
    
    updateTDDisplay();
}

function tdGameLoop() {
    if (!tdGameRunning) return;
    
    const currentTime = Date.now();
    
    // FIXED: Controlled enemy spawning
    if (waveSpawning && enemiesSpawned < enemiesToSpawn) {
        // Spawn one enemy every 1000ms (1 second)
        if (currentTime - lastSpawnTime >= 1000) {
            spawnEnemy();
            enemiesSpawned++;
            lastSpawnTime = currentTime;
            
            // Check if all enemies for this wave have been spawned
            if (enemiesSpawned >= enemiesToSpawn) {
                waveSpawning = false;
                document.getElementById('td-status').textContent = `Wave ${tdWave}: ${enemies.length} enemies remaining`;
            }
        }
    }
    
    // Update game objects
    updateTowerDefense();
    drawTowerDefense();
    
    // FIXED: Better wave completion logic
    if (waveActive && !waveSpawning && enemies.length === 0) {
        // Wave completed
        waveActive = false;
        waveCompleteTime = currentTime;
        
        tdScore += tdWave * 50;
        tdMoney += 15 + tdWave * 5;
        tdWave++;
        
        updateTDDisplay();
        document.getElementById('td-status').textContent = `Wave completed! Click "Start Wave" for Wave ${tdWave}`;
    }
    
    // Check game over
    if (tdLives <= 0) {
        tdGameRunning = false;
        document.getElementById('td-status').textContent = `üíÄ Game Over! Final Score: ${tdScore}`;
        return;
    }
    
    requestAnimationFrame(tdGameLoop);
}

// FIXED: Spawn single enemy function
function spawnEnemy() {
    // Choose enemy type based on wave
    let enemyType = 'basic';
    const rand = Math.random();
    
    if (tdWave >= 3 && rand < 0.25) enemyType = 'fast';
    if (tdWave >= 5 && rand < 0.15) enemyType = 'tank';
    
    const enemyData = enemyTypes[enemyType];
    const hpMultiplier = 1 + (tdWave - 1) * 0.3; // Gradual HP increase
    
    enemies.push({
        x: path[0].x - 20, // Start slightly off-screen
        y: path[0].y,
        pathIndex: 0,
        type: enemyType,
        hp: Math.floor(enemyData.hp * hpMultiplier),
        maxHp: Math.floor(enemyData.hp * hpMultiplier),
        speed: enemyData.speed,
        reward: enemyData.reward,
        color: enemyData.color,
        size: enemyData.size
    });
}

function updateTowerDefense() {
    const currentTime = Date.now();
    
    // Update enemies
    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        
        // Move enemy along path
        if (enemy.pathIndex < path.length - 1) {
            const targetPoint = path[enemy.pathIndex + 1];
            const dx = targetPoint.x - enemy.x;
            const dy = targetPoint.y - enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < enemy.speed * 2) {
                enemy.pathIndex++;
                if (enemy.pathIndex >= path.length - 1) {
                    // Enemy reached end
                    tdLives--;
                    enemies.splice(i, 1);
                    updateTDDisplay();
                    continue;
                }
            } else {
                enemy.x += (dx / distance) * enemy.speed;
                enemy.y += (dy / distance) * enemy.speed;
            }
        }
    }
    
    // Tower shooting
    towers.forEach(tower => {
        if (currentTime - tower.lastShot >= tower.fireRate) {
            // Find closest enemy in range
            let closestEnemy = null;
            let closestDistance = tower.range;
            
            enemies.forEach(enemy => {
                const distance = Math.sqrt((tower.x - enemy.x) ** 2 + (tower.y - enemy.y) ** 2);
                if (distance <= closestDistance) {
                    closestEnemy = enemy;
                    closestDistance = distance;
                }
            });
            
            if (closestEnemy) {
                // Create projectile
                projectiles.push({
                    x: tower.x,
                    y: tower.y,
                    targetX: closestEnemy.x,
                    targetY: closestEnemy.y,
                    damage: tower.damage,
                    speed: 8,
                    color: tower.color
                });
                
                tower.lastShot = currentTime;
            }
        }
    });
    
    // Update projectiles
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        const dx = projectile.targetX - projectile.x;
        const dy = projectile.targetY - projectile.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < projectile.speed) {
            // Hit target area - damage nearby enemies
            for (let j = enemies.length - 1; j >= 0; j--) {
                const enemy = enemies[j];
                const enemyDistance = Math.sqrt((projectile.targetX - enemy.x) ** 2 + (projectile.targetY - enemy.y) ** 2);
                if (enemyDistance <= 25) {
                    enemy.hp -= projectile.damage;
                    
                    if (enemy.hp <= 0) {
                        tdMoney += enemy.reward;
                        tdScore += enemy.reward * 2;
                        enemies.splice(j, 1);
                        updateTDDisplay();
                    }
                    break; // Only hit one enemy per projectile
                }
            }
            
            projectiles.splice(i, 1);
        } else {
            projectile.x += (dx / distance) * projectile.speed;
            projectile.y += (dy / distance) * projectile.speed;
        }
    }
}

function drawTowerDefense() {
    if (!tdCtx) return;
    
    tdCtx.clearRect(0, 0, tdCanvas.width, tdCanvas.height);
    
    // Draw background
    tdCtx.fillStyle = '#90EE90';
    tdCtx.fillRect(0, 0, tdCanvas.width, tdCanvas.height);
    
    // Draw path
    tdCtx.strokeStyle = '#8B4513';
    tdCtx.lineWidth = 50;
    tdCtx.beginPath();
    path.forEach((point, index) => {
        if (index === 0) {
            tdCtx.moveTo(point.x, point.y);
        } else {
            tdCtx.lineTo(point.x, point.y);
        }
    });
    tdCtx.stroke();
    
    // Draw towers
    towers.forEach(tower => {
        // Tower range (when selected)
        if (selectedTowerType === tower.type && !sellModeActive) {
            tdCtx.globalAlpha = 0.3;
            tdCtx.strokeStyle = tower.color;
            tdCtx.lineWidth = 2;
            tdCtx.beginPath();
            tdCtx.arc(tower.x, tower.y, tower.range, 0, Math.PI * 2);
            tdCtx.stroke();
            tdCtx.globalAlpha = 1;
        }
        
        // Tower body
        tdCtx.fillStyle = tower.color;
        tdCtx.beginPath();
        tdCtx.arc(tower.x, tower.y, tower.size, 0, Math.PI * 2);
        tdCtx.fill();
        
        // Tower outline
        tdCtx.strokeStyle = '#000';
        tdCtx.lineWidth = 2;
        tdCtx.stroke();
    });
    
    // Draw enemies
    enemies.forEach(enemy => {
        // Enemy body
        tdCtx.fillStyle = enemy.color;
        tdCtx.beginPath();
        tdCtx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
        tdCtx.fill();
        
        // Enemy outline
        tdCtx.strokeStyle = '#000';
        tdCtx.lineWidth = 1;
        tdCtx.stroke();
        
        // Health bar
        const barWidth = enemy.size * 2.5;
        const barHeight = 4;
        const healthPercent = enemy.hp / enemy.maxHp;
        
        // Health bar background
        tdCtx.fillStyle = '#FF0000';
        tdCtx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.size - 12, barWidth, barHeight);
        
        // Health bar foreground
        tdCtx.fillStyle = '#00FF00';
        tdCtx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.size - 12, barWidth * healthPercent, barHeight);
    });
    
    // Draw projectiles
    projectiles.forEach(projectile => {
        tdCtx.fillStyle = projectile.color;
        tdCtx.beginPath();
        tdCtx.arc(projectile.x, projectile.y, 4, 0, Math.PI * 2);
        tdCtx.fill();
        
        // Projectile trail
        tdCtx.strokeStyle = projectile.color;
        tdCtx.lineWidth = 2;
        tdCtx.globalAlpha = 0.5;
        tdCtx.beginPath();
        const trailLength = 10;
        const dx = projectile.targetX - projectile.x;
        const dy = projectile.targetY - projectile.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance > 0) {
            const trailX = projectile.x - (dx / distance) * trailLength;
            const trailY = projectile.y - (dy / distance) * trailLength;
            tdCtx.moveTo(trailX, trailY);
            tdCtx.lineTo(projectile.x, projectile.y);
        }
        tdCtx.stroke();
        tdCtx.globalAlpha = 1;
    });
}

function updateTDDisplay() {
    document.getElementById('td-money').textContent = tdMoney;
    document.getElementById('td-lives').textContent = tdLives;
    document.getElementById('td-wave').textContent = tdWave;
    document.getElementById('td-score').textContent = tdScore;
}
        // Simple Dino Runner
        let dinoCanvas, dinoCtx;
        let dinoPlayer, dinoObstacles, dinoScore, dinoHighScore;
        let dinoGameRunning = false;
        let dinoIsJumping = false;
        let dinoJumpVelocity = 0;

        function setupDinoGame() {
            dinoCanvas = document.getElementById('dino-canvas');
            if (!dinoCanvas) return;
            
            dinoCtx = dinoCanvas.getContext('2d');
            
            try {
                dinoHighScore = parseInt(localStorage.getItem('dinoHighScore')) || 0;
            } catch (error) {
                dinoHighScore = 0;
            }
            document.getElementById('dino-high-score').textContent = dinoHighScore;
            
            initDinoGame();
            
            dinoCanvas.ontouchstart = (e) => {
                e.preventDefault();
                jumpDino();
            };
        }

        function initDinoGame() {
            dinoPlayer = { x: 50, y: 120, width: 20, height: 20 };
            dinoObstacles = [];
            dinoScore = 0;
            dinoGameRunning = false;
            dinoIsJumping = false;
            dinoJumpVelocity = 0;
            updateDinoScore();
            drawDinoGame();
        }

        function startDinoGame() {
            if (dinoGameRunning) return;
            dinoGameRunning = true;
            document.getElementById('dino-status').textContent = '';
            dinoGameLoop();
        }

        function jumpDino() {
            if (!dinoIsJumping && dinoGameRunning) {
                dinoIsJumping = true;
                dinoJumpVelocity = -10;
            }
        }

        function dinoGameLoop() {
            if (!dinoGameRunning) return;
            
            updateDinoGame();
            drawDinoGame();
            
            requestAnimationFrame(dinoGameLoop);
        }

        function updateDinoGame() {
            dinoScore += 1;
            updateDinoScore();
            
            if (dinoIsJumping) {
                dinoPlayer.y += dinoJumpVelocity;
                dinoJumpVelocity += 0.8;
                
                if (dinoPlayer.y >= 120) {
                    dinoPlayer.y = 120;
                    dinoIsJumping = false;
                    dinoJumpVelocity = 0;
                }
            }
            
            if (Math.random() < 0.02) {
                dinoObstacles.push({
                    x: dinoCanvas.width,
                    y: 120,
                    width: 15,
                    height: 20
                });
            }
            
            dinoObstacles.forEach(obstacle => {
                obstacle.x -= 3;
            });
            
            dinoObstacles = dinoObstacles.filter(obstacle => obstacle.x + obstacle.width > 0);
            
            dinoObstacles.forEach(obstacle => {
                if (dinoPlayer.x < obstacle.x + obstacle.width &&
                    dinoPlayer.x + dinoPlayer.width > obstacle.x &&
                    dinoPlayer.y < obstacle.y + obstacle.height &&
                    dinoPlayer.y + dinoPlayer.height > obstacle.y) {
                    
                    dinoGameRunning = false;
                    
                    if (dinoScore > dinoHighScore) {
                        dinoHighScore = dinoScore;
                        try {
                            localStorage.setItem('dinoHighScore', dinoHighScore.toString());
                        } catch (error) {}
                        document.getElementById('dino-high-score').textContent = dinoHighScore;
                        document.getElementById('dino-status').textContent = 'üéâ New High Score!';
                    } else {
                        document.getElementById('dino-status').textContent = 'Game Over! Tap Start to play again.';
                    }
                }
            });
        }

        function drawDinoGame() {
            dinoCtx.clearRect(0, 0, dinoCanvas.width, dinoCanvas.height);
            
            dinoCtx.fillStyle = '#5D5CDE';
            dinoCtx.fillRect(dinoPlayer.x, dinoPlayer.y, dinoPlayer.width, dinoPlayer.height);
            
            dinoCtx.fillStyle = '#333';
            dinoObstacles.forEach(obstacle => {
                dinoCtx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            });
            
            // Ground line
            dinoCtx.strokeStyle = '#333';
            dinoCtx.lineWidth = 2;
            dinoCtx.beginPath();
            dinoCtx.moveTo(0, 140);
            dinoCtx.lineTo(dinoCanvas.width, 140);
            dinoCtx.stroke();
        }

        function updateDinoScore() {
            document.getElementById('dino-score').textContent = dinoScore;
        }

        // Shape Drawing Game
        let shapeCanvas, shapeCtx;
        let currentShape = 'circle';
        let shapeColor = '#5D5CDE';
        let shapeSize = 30;

        function setupShapeDrawing() {
            shapeCanvas = document.getElementById('shape-canvas');
            if (!shapeCanvas) return;
            
            shapeCtx = shapeCanvas.getContext('2d');
            clearShapeCanvas();
            
            // Remove existing listeners
            shapeCanvas.onclick = null;
            shapeCanvas.ontouchstart = null;
            
            // Mouse and touch events
            shapeCanvas.onclick = drawShape;
            shapeCanvas.ontouchstart = (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = shapeCanvas.getBoundingClientRect();
                const x = (touch.clientX - rect.left) * (shapeCanvas.width / rect.width);
                const y = (touch.clientY - rect.top) * (shapeCanvas.height / rect.height);
                drawShapeAt(x, y);
            };
        }

        function setCurrentShape(shape) {
            currentShape = shape;
            // Update button appearance
            document.querySelectorAll('.shape-btn').forEach(btn => {
                btn.style.backgroundColor = '#5D5CDE';
            });
            event.target.style.backgroundColor = '#4845B8';
        }

        function setShapeColor(color) {
            shapeColor = color;
        }

        function setShapeSize(size) {
            shapeSize = parseInt(size);
            document.getElementById('shape-size-display').textContent = size + 'px';
        }

        function drawShape(e) {
            const rect = shapeCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (shapeCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (shapeCanvas.height / rect.height);
            drawShapeAt(x, y);
        }

        function drawShapeAt(x, y) {
            shapeCtx.fillStyle = shapeColor;
            shapeCtx.strokeStyle = shapeColor;
            shapeCtx.lineWidth = 2;
            
            switch (currentShape) {
                case 'circle':
                    shapeCtx.beginPath();
                    shapeCtx.arc(x, y, shapeSize, 0, Math.PI * 2);
                    shapeCtx.fill();
                    break;
                    
                case 'square':
                    shapeCtx.fillRect(x - shapeSize, y - shapeSize, shapeSize * 2, shapeSize * 2);
                    break;
                    
                case 'triangle':
                    shapeCtx.beginPath();
                    shapeCtx.moveTo(x, y - shapeSize);
                    shapeCtx.lineTo(x - shapeSize, y + shapeSize);
                    shapeCtx.lineTo(x + shapeSize, y + shapeSize);
                    shapeCtx.closePath();
                    shapeCtx.fill();
                    break;
                    
                case 'line':
                    shapeCtx.beginPath();
                    shapeCtx.moveTo(x - shapeSize, y);
                    shapeCtx.lineTo(x + shapeSize, y);
                    shapeCtx.stroke();
                    break;
            }
        }

        function clearShapeCanvas() {
            shapeCtx.fillStyle = '#ffffff';
            shapeCtx.fillRect(0, 0, shapeCanvas.width, shapeCanvas.height);
        }

        // Dot Connect Game
        let dotCanvas, dotCtx;
        let dots = [];
        let connections = [];
        let currentDot = 1;
        let dotGameComplete = false;

        function setupDotConnect() {
            dotCanvas = document.getElementById('dot-canvas');
            if (!dotCanvas) return;
            
            dotCtx = dotCanvas.getContext('2d');
            generateDotPuzzle();
            
            // Click/touch events
            dotCanvas.onclick = handleDotClick;
            dotCanvas.ontouchstart = (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = dotCanvas.getBoundingClientRect();
                const x = (touch.clientX - rect.left) * (dotCanvas.width / rect.width);
                const y = (touch.clientY - rect.top) * (dotCanvas.height / rect.height);
                handleDotClickAt(x, y);
            };
        }

        function generateDotPuzzle() {
            dots = [];
            connections = [];
            currentDot = 1;
            dotGameComplete = false;
            
            // Scale factor for mobile (400x400 instead of 500x500)
            const scale = 0.8;
            
            // Generate dots for various shapes (scaled down for mobile)
            const puzzleShapes = [
                // Small House
                [
                    {x: 100*scale + 50, y: 280*scale + 30}, // 1 - bottom left
                    {x: 200*scale + 50, y: 280*scale + 30}, // 2 - bottom right
                    {x: 200*scale + 50, y: 180*scale + 30}, // 3 - top right wall
                    {x: 180*scale + 50, y: 160*scale + 30}, // 4 - roof right
                    {x: 150*scale + 50, y: 120*scale + 30}, // 5 - roof peak
                    {x: 120*scale + 50, y: 160*scale + 30}, // 6 - roof left
                    {x: 100*scale + 50, y: 180*scale + 30}, // 7 - top left wall
                    {x: 100*scale + 50, y: 280*scale + 30}, // 8 - back to start
                    {x: 120*scale + 50, y: 260*scale + 30}, // 9 - door left
                    {x: 120*scale + 50, y: 220*scale + 30}, // 10 - door top left
                    {x: 140*scale + 50, y: 220*scale + 30}, // 11 - door top right
                    {x: 140*scale + 50, y: 260*scale + 30}, // 12 - door bottom right
                    {x: 120*scale + 50, y: 260*scale + 30}, // 13 - complete door
                    {x: 170*scale + 50, y: 240*scale + 30}, // 14 - window bottom left
                    {x: 190*scale + 50, y: 240*scale + 30}, // 15 - window bottom right
                    {x: 190*scale + 50, y: 220*scale + 30}, // 16 - window top right
                    {x: 170*scale + 50, y: 220*scale + 30}, // 17 - window top left
                    {x: 170*scale + 50, y: 240*scale + 30}  // 18 - complete window
                ],
                // Star
                [
                    {x: 175*scale + 50, y: 80*scale + 30}, // 1 - top point
                    {x: 190*scale + 50, y: 120*scale + 30}, // 2 - inner top right
                    {x: 230*scale + 50, y: 120*scale + 30}, // 3 - right point
                    {x: 205*scale + 50, y: 150*scale + 30}, // 4 - inner right
                    {x: 220*scale + 50, y: 190*scale + 30}, // 5 - bottom right point
                    {x: 175*scale + 50, y: 170*scale + 30}, // 6 - inner bottom
                    {x: 130*scale + 50, y: 190*scale + 30}, // 7 - bottom left point
                    {x: 145*scale + 50, y: 150*scale + 30}, // 8 - inner left
                    {x: 120*scale + 50, y: 120*scale + 30}, // 9 - left point
                    {x: 160*scale + 50, y: 120*scale + 30}, // 10 - inner top left
                    {x: 175*scale + 50, y: 80*scale + 30}  // 11 - back to top
                ],
                // Diamond
                [
                    {x: 175*scale + 50, y: 70*scale + 30}, // 1 - top point
                    {x: 220*scale + 50, y: 110*scale + 30}, // 2 - top right
                    {x: 260*scale + 50, y: 170*scale + 30}, // 3 - right point
                    {x: 220*scale + 50, y: 230*scale + 30}, // 4 - bottom right
                    {x: 175*scale + 50, y: 270*scale + 30}, // 5 - bottom point
                    {x: 130*scale + 50, y: 230*scale + 30}, // 6 - bottom left
                    {x: 90*scale + 50, y: 170*scale + 30}, // 7 - left point
                    {x: 130*scale + 50, y: 110*scale + 30}, // 8 - top left
                    {x: 175*scale + 50, y: 70*scale + 30}  // 9 - back to top
                ],
                // Fish
                [
                    {x: 90*scale + 50, y: 175*scale + 30}, // 1 - tail left
                    {x: 110*scale + 50, y: 140*scale + 30}, // 2 - tail top
                    {x: 130*scale + 50, y: 125*scale + 30}, // 3 - body top left
                    {x: 190*scale + 50, y: 115*scale + 30}, // 4 - body top center
                    {x: 240*scale + 50, y: 125*scale + 30}, // 5 - head top
                    {x: 260*scale + 50, y: 150*scale + 30}, // 6 - nose
                    {x: 270*scale + 50, y: 175*scale + 30}, // 7 - mouth tip
                    {x: 260*scale + 50, y: 200*scale + 30}, // 8 - mouth bottom
                    {x: 240*scale + 50, y: 225*scale + 30}, // 9 - head bottom
                    {x: 190*scale + 50, y: 235*scale + 30}, // 10 - body bottom center
                    {x: 130*scale + 50, y: 225*scale + 30}, // 11 - body bottom left
                    {x: 110*scale + 50, y: 210*scale + 30}, // 12 - tail bottom
                    {x: 90*scale + 50, y: 175*scale + 30}, // 13 - back to tail
                    {x: 160*scale + 50, y: 160*scale + 30}, // 14 - eye
                    {x: 170*scale + 50, y: 155*scale + 30}, // 15 - eye top
                    {x: 175*scale + 50, y: 160*scale + 30}, // 16 - eye right
                    {x: 170*scale + 50, y: 165*scale + 30}, // 17 - eye bottom
                    {x: 160*scale + 50, y: 160*scale + 30}  // 18 - complete eye
                ],
                // Tree
                [
                    {x: 168*scale + 50, y: 280*scale + 30}, // 1 - trunk bottom left
                    {x: 182*scale + 50, y: 280*scale + 30}, // 2 - trunk bottom right
                    {x: 182*scale + 50, y: 210*scale + 30}, // 3 - trunk top right
                    {x: 196*scale + 50, y: 210*scale + 30}, // 4 - branch right base
                    {x: 224*scale + 50, y: 196*scale + 30}, // 5 - branch right tip
                    {x: 210*scale + 50, y: 182*scale + 30}, // 6 - leaves right outer
                    {x: 245*scale + 50, y: 154*scale + 30}, // 7 - leaves right top
                    {x: 224*scale + 50, y: 126*scale + 30}, // 8 - leaves top right
                    {x: 196*scale + 50, y: 112*scale + 30}, // 9 - leaves top center right
                    {x: 175*scale + 50, y: 98*scale + 30}, // 10 - leaves top center
                    {x: 154*scale + 50, y: 112*scale + 30}, // 11 - leaves top center left
                    {x: 126*scale + 50, y: 126*scale + 30}, // 12 - leaves top left
                    {x: 105*scale + 50, y: 154*scale + 30}, // 13 - leaves left top
                    {x: 140*scale + 50, y: 182*scale + 30}, // 14 - leaves left outer
                    {x: 126*scale + 50, y: 196*scale + 30}, // 15 - branch left tip
                    {x: 154*scale + 50, y: 210*scale + 30}, // 16 - branch left base
                    {x: 168*scale + 50, y: 210*scale + 30}, // 17 - trunk top left
                    {x: 168*scale + 50, y: 280*scale + 30}  // 18 - back to bottom
                ]
            ];
            
            const selectedShape = puzzleShapes[Math.floor(Math.random() * puzzleShapes.length)];
            
            dots = selectedShape.map((pos, index) => ({
                x: pos.x,
                y: pos.y,
                number: index + 1,
                connected: false
            }));
            
            updateDotDisplay();
            drawDotPuzzle();
        }

        function handleDotClick(e) {
            const rect = dotCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (dotCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (dotCanvas.height / rect.height);
            handleDotClickAt(x, y);
        }

        function handleDotClickAt(x, y) {
            if (dotGameComplete) return;
            
            // Find clicked dot
            const clickedDot = dots.find(dot => {
                const distance = Math.sqrt((x - dot.x) ** 2 + (y - dot.y) ** 2);
                return distance <= 20 && dot.number === currentDot;
            });
            
            if (clickedDot) {
                clickedDot.connected = true;
                
                // Draw connection line if not the first dot
                if (currentDot > 1) {
                    const prevDot = dots.find(d => d.number === currentDot - 1);
                    connections.push({
                        from: prevDot,
                        to: clickedDot
                    });
                }
                
                currentDot++;
                updateDotDisplay();
                drawDotPuzzle();
                
                // Check if puzzle is complete
                if (currentDot > dots.length) {
                    dotGameComplete = true;
                    document.getElementById('dot-result').textContent = 'üéâ Picture revealed!';
                }
            }
        }

        function drawDotPuzzle() {
            dotCtx.clearRect(0, 0, dotCanvas.width, dotCanvas.height);
            
            // Draw connections
            dotCtx.strokeStyle = '#5D5CDE';
            dotCtx.lineWidth = 3;
            connections.forEach(conn => {
                dotCtx.beginPath();
                dotCtx.moveTo(conn.from.x, conn.from.y);
                dotCtx.lineTo(conn.to.x, conn.to.y);
                dotCtx.stroke();
            });
            
            // Draw dots
            dots.forEach(dot => {
                // Dot circle
                dotCtx.fillStyle = dot.connected ? '#10B981' : '#EF4444';
                dotCtx.beginPath();
                dotCtx.arc(dot.x, dot.y, 15, 0, Math.PI * 2);
                dotCtx.fill();
                
                // Number label
                dotCtx.fillStyle = 'white';
                dotCtx.font = 'bold 14px Arial';
                dotCtx.textAlign = 'center';
                dotCtx.textBaseline = 'middle';
                dotCtx.fillText(dot.number, dot.x, dot.y);
            });
            
            // Highlight next dot
            if (currentDot <= dots.length) {
                const nextDot = dots.find(d => d.number === currentDot);
                if (nextDot) {
                    dotCtx.strokeStyle = '#F59E0B';
                    dotCtx.lineWidth = 4;
                    dotCtx.beginPath();
                    dotCtx.arc(nextDot.x, nextDot.y, 20, 0, Math.PI * 2);
                    dotCtx.stroke();
                }
            }
        }

        function updateDotDisplay() {
            document.getElementById('dot-current').textContent = Math.min(currentDot, dots.length);
            document.getElementById('dot-total').textContent = dots.length;
            document.getElementById('dot-progress').textContent = Math.max(0, currentDot - 1);
        }

        function clearDotConnections() {
            connections = [];
            currentDot = 1;
            dotGameComplete = false;
            
            dots.forEach(dot => {
                dot.connected = false;
            });
            
            updateDotDisplay();
            drawDotPuzzle();
            document.getElementById('dot-result').textContent = '';
        }

        // Pattern Match Game
        let patternLevel = 1;
        let patternScore = 0;
        let targetPattern = [];
        let playerPattern = [];
        const patternSize = 5; // 5x5 grid

        function setupPatternMatch() {
            patternLevel = 1;
            patternScore = 0;
            targetPattern = Array(patternSize).fill().map(() => Array(patternSize).fill(false));
            playerPattern = Array(patternSize).fill().map(() => Array(patternSize).fill(false));
            
            generateNewPattern();
        }

        function generateNewPattern() {
            // Clear patterns
            targetPattern = Array(patternSize).fill().map(() => Array(patternSize).fill(false));
            playerPattern = Array(patternSize).fill().map(() => Array(patternSize).fill(false));
            
            // Generate random pattern based on level
            const numCells = Math.min(3 + patternLevel, 12); // Increase complexity with level
            
            for (let i = 0; i < numCells; i++) {
                let row, col;
                do {
                    row = Math.floor(Math.random() * patternSize);
                    col = Math.floor(Math.random() * patternSize);
                } while (targetPattern[row][col]);
                
                targetPattern[row][col] = true;
            }
            
            renderPatternGrids();
            updatePatternDisplay();
            document.getElementById('pattern-result').textContent = '';
        }

        function renderPatternGrids() {
            renderPatternGrid('pattern-target', targetPattern, false);
            renderPatternGrid('pattern-player', playerPattern, true);
        }

        function renderPatternGrid(containerId, pattern, clickable) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            const grid = document.createElement('div');
            grid.className = 'grid gap-1';
            grid.style.gridTemplateColumns = `repeat(${patternSize}, 1fr)`;
            
            for (let row = 0; row < patternSize; row++) {
                for (let col = 0; col < patternSize; col++) {
                    const cell = document.createElement('div');
                    cell.className = `w-8 h-8 border-2 border-gray-400 ${
                        pattern[row][col] 
                            ? 'bg-primary' 
                            : 'bg-white dark:bg-gray-600'
                    } ${clickable ? 'cursor-pointer hover:bg-opacity-80' : ''}`;
                    
                    if (clickable) {
                        cell.onclick = () => togglePatternCell(row, col);
                    }
                    
                    grid.appendChild(cell);
                }
            }
            
            container.appendChild(grid);
        }

        function togglePatternCell(row, col) {
            playerPattern[row][col] = !playerPattern[row][col];
            renderPatternGrid('pattern-player', playerPattern, true);
        }

        function clearPlayerPattern() {
            playerPattern = Array(patternSize).fill().map(() => Array(patternSize).fill(false));
            renderPatternGrid('pattern-player', playerPattern, true);
        }

        function checkPatternMatch() {
            let matches = 0;
            let totalCells = patternSize * patternSize;
            
            for (let row = 0; row < patternSize; row++) {
                for (let col = 0; col < patternSize; col++) {
                    if (targetPattern[row][col] === playerPattern[row][col]) {
                        matches++;
                    }
                }
            }
            
            const accuracy = Math.round((matches / totalCells) * 100);
            
            if (accuracy === 100) {
                patternScore += patternLevel * 10;
                patternLevel++;
                document.getElementById('pattern-result').textContent = 'üéâ Perfect match!';
                document.getElementById('pattern-result').style.color = '#16a34a';
                
                setTimeout(() => {
                    generateNewPattern();
                }, 2000);
            } else if (accuracy >= 80) {
                patternScore += Math.floor(patternLevel * 5);
                document.getElementById('pattern-result').textContent = `üÜó Good! ${accuracy}% accuracy`;
                document.getElementById('pattern-result').style.color = '#f59e0b';
            } else {
                document.getElementById('pattern-result').textContent = `‚ùå Try again! ${accuracy}% accuracy`;
                document.getElementById('pattern-result').style.color = '#dc2626';
            }
            
            updatePatternDisplay();
        }

        function updatePatternDisplay() {
            document.getElementById('pattern-level').textContent = patternLevel;
            document.getElementById('pattern-score').textContent = patternScore;
        }

        // Color Mixer Game
        let targetR = 128, targetG = 128, targetB = 128;
        let colorScore = 0;

        function setupColorMixer() {
            colorScore = 0;
            generateNewTargetColor();
            updatePlayerColor();
        }

        function generateNewTargetColor() {
            targetR = Math.floor(Math.random() * 256);
            targetG = Math.floor(Math.random() * 256);
            targetB = Math.floor(Math.random() * 256);
            
            const targetColor = document.getElementById('target-color');
            targetColor.style.backgroundColor = `rgb(${targetR}, ${targetG}, ${targetB})`;
            document.getElementById('target-rgb').textContent = `(${targetR}, ${targetG}, ${targetB})`;
            
            updateColorAccuracy();
        }

        function updatePlayerColor() {
            const r = document.getElementById('red-slider').value;
            const g = document.getElementById('green-slider').value;
            const b = document.getElementById('blue-slider').value;
            
            document.getElementById('red-value').textContent = r;
            document.getElementById('green-value').textContent = g;
            document.getElementById('blue-value').textContent = b;
            
            const playerColor = document.getElementById('player-color');
            playerColor.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
            document.getElementById('player-rgb').textContent = `(${r}, ${g}, ${b})`;
            
            updateColorAccuracy();
        }

        function updateColorAccuracy() {
            const r = parseInt(document.getElementById('red-slider').value);
            const g = parseInt(document.getElementById('green-slider').value);
            const b = parseInt(document.getElementById('blue-slider').value);
            
            const rDiff = Math.abs(r - targetR);
            const gDiff = Math.abs(g - targetG);
            const bDiff = Math.abs(b - targetB);
            
            const totalDiff = rDiff + gDiff + bDiff;
            const maxDiff = 255 * 3; // Maximum possible difference
            const accuracy = Math.max(0, Math.round(100 - (totalDiff / maxDiff) * 100));
            
            document.getElementById('color-accuracy').textContent = accuracy + '%';
        }

        function checkColorMatch() {
            const r = parseInt(document.getElementById('red-slider').value);
            const g = parseInt(document.getElementById('green-slider').value);
            const b = parseInt(document.getElementById('blue-slider').value);
            
            const rDiff = Math.abs(r - targetR);
            const gDiff = Math.abs(g - targetG);
            const bDiff = Math.abs(b - targetB);
            
            const totalDiff = rDiff + gDiff + bDiff;
            const accuracy = Math.max(0, Math.round(100 - (totalDiff / (255 * 3)) * 100));
            
            if (accuracy >= 95) {
                colorScore += 100;
                alert('üéâ Perfect match! +100 points');
            } else if (accuracy >= 85) {
                colorScore += 50;
                alert('üëç Very close! +50 points');
            } else if (accuracy >= 70) {
                colorScore += 25;
                alert('üÜó Good attempt! +25 points');
            } else {
                alert('Keep trying! Accuracy: ' + accuracy + '%');
            }
            
            document.getElementById('color-score').textContent = colorScore;
        }

        // Anagram Game
        let anagramScore = 0;
        let anagramRound = 1;
        let currentWord = '';
        let currentHint = '';
        let playerAnswer = [];

        const anagramWords = [
            // Original words
            { word: 'LISTEN', hint: 'To hear carefully' },
            { word: 'SILENT', hint: 'Making no noise' },
            { word: 'PLANET', hint: 'A celestial body' },
            { word: 'TEACHER', hint: 'Someone who educates' },
            { word: 'STUDENT', hint: 'Someone who learns' },
            { word: 'GARDEN', hint: 'Place where plants grow' },
            { word: 'DANGER', hint: 'Risk or threat' },
            { word: 'FRIEND', hint: 'A close companion' },
            { word: 'WINNER', hint: 'Someone who succeeds' },
            { word: 'ANSWER', hint: 'A response to a question' },
            
            // Animals
            { word: 'TIGER', hint: 'Large striped cat' },
            { word: 'HORSE', hint: 'Farm animal you can ride' },
            { word: 'MOUSE', hint: 'Small rodent' },
            { word: 'EAGLE', hint: 'Bird of prey with keen eyesight' },
            { word: 'SHARK', hint: 'Ocean predator with sharp teeth' },
            { word: 'WHALE', hint: 'Largest marine mammal' },
            { word: 'SNAKE', hint: 'Slithering reptile' },
            { word: 'RABBIT', hint: 'Hopping animal with long ears' },
            { word: 'TURTLE', hint: 'Slow reptile with a shell' },
            { word: 'MONKEY', hint: 'Primate that swings from trees' },
            
            // Food & Drinks
            { word: 'BREAD', hint: 'Baked staple food' },
            { word: 'CHEESE', hint: 'Dairy product from milk' },
            { word: 'APPLE', hint: 'Red or green fruit' },
            { word: 'ORANGE', hint: 'Citrus fruit' },
            { word: 'BANANA', hint: 'Yellow curved fruit' },
            { word: 'COFFEE', hint: 'Popular morning beverage' },
            { word: 'WATER', hint: 'Essential clear liquid' },
            { word: 'SUGAR', hint: 'Sweet granules' },
            { word: 'HONEY', hint: 'Sweet substance made by bees' },
            { word: 'PIZZA', hint: 'Italian dish with toppings' },
            
            // Colors
            { word: 'RED', hint: 'Color of blood' },
            { word: 'BLUE', hint: 'Color of the sky' },
            { word: 'GREEN', hint: 'Color of grass' },
            { word: 'YELLOW', hint: 'Color of the sun' },
            { word: 'PURPLE', hint: 'Mix of red and blue' },
            { word: 'ORANGE', hint: 'Color of a sunset' },
            { word: 'PINK', hint: 'Light red color' },
            { word: 'BROWN', hint: 'Color of tree bark' },
            { word: 'BLACK', hint: 'Darkest color' },
            { word: 'WHITE', hint: 'Lightest color' },
            
            // Nature & Weather
            { word: 'CLOUD', hint: 'Fluffy white formations in sky' },
            { word: 'STORM', hint: 'Violent weather with rain and wind' },
            { word: 'OCEAN', hint: 'Large body of salt water' },
            { word: 'MOUNTAIN', hint: 'High elevation landform' },
            { word: 'FOREST', hint: 'Area densely packed with trees' },
            { word: 'RIVER', hint: 'Flowing body of fresh water' },
            { word: 'FLOWER', hint: 'Colorful part of a plant' },
            { word: 'STONE', hint: 'Hard mineral matter' },
            { word: 'WIND', hint: 'Moving air' },
            { word: 'FIRE', hint: 'Hot glowing combustion' },
            
            // Technology & Modern Life
            { word: 'PHONE', hint: 'Device for making calls' },
            { word: 'COMPUTER', hint: 'Electronic calculating machine' },
            { word: 'CAMERA', hint: 'Device for taking photos' },
            { word: 'INTERNET', hint: 'Global network of computers' },
            { word: 'SCREEN', hint: 'Display surface' },
            { word: 'ROBOT', hint: 'Automated mechanical being' },
            { word: 'BATTERY', hint: 'Portable power source' },
            { word: 'KEYBOARD', hint: 'Input device with letters' },
            { word: 'MOUSE', hint: 'Computer pointing device' },
            { word: 'EMAIL', hint: 'Electronic mail' },
            
            // Transportation
            { word: 'CAR', hint: 'Four-wheeled motor vehicle' },
            { word: 'TRAIN', hint: 'Railway transportation' },
            { word: 'PLANE', hint: 'Flying vehicle' },
            { word: 'SHIP', hint: 'Large boat' },
            { word: 'BIKE', hint: 'Two-wheeled pedal vehicle' },
            { word: 'BUS', hint: 'Large passenger vehicle' },
            { word: 'TRUCK', hint: 'Large cargo vehicle' },
            { word: 'BOAT', hint: 'Small water vessel' },
            { word: 'ROCKET', hint: 'Space vehicle' },
            { word: 'SUBWAY', hint: 'Underground train' },
            
            // Sports & Activities
            { word: 'SOCCER', hint: 'World\'s most popular sport' },
            { word: 'TENNIS', hint: 'Racket sport with a net' },
            { word: 'HOCKEY', hint: 'Ice sport with sticks' },
            { word: 'GOLF', hint: 'Sport played on a course with holes' },
            { word: 'BOXING', hint: 'Fighting sport with gloves' },
            { word: 'CHESS', hint: 'Strategic board game' },
            { word: 'DANCE', hint: 'Rhythmic body movement' },
            { word: 'MUSIC', hint: 'Organized sound and rhythm' },
            { word: 'PAINT', hint: 'Artistic medium' },
            { word: 'BOOK', hint: 'Written work with pages' },
            
            // Body Parts
            { word: 'HEAD', hint: 'Top part of the body' },
            { word: 'HAND', hint: 'Part at the end of your arm' },
            { word: 'FOOT', hint: 'Part at the end of your leg' },
            { word: 'HEART', hint: 'Organ that pumps blood' },
            { word: 'BRAIN', hint: 'Thinking organ in your head' },
            { word: 'FINGER', hint: 'Digit on your hand' },
            { word: 'TOOTH', hint: 'Hard white structure in mouth' },
            { word: 'NOSE', hint: 'Organ for smelling' },
            { word: 'EAR', hint: 'Organ for hearing' },
            { word: 'EYE', hint: 'Organ for seeing' },
            
            // Household Items
            { word: 'CHAIR', hint: 'Furniture for sitting' },
            { word: 'TABLE', hint: 'Flat surface with legs' },
            { word: 'DOOR', hint: 'Entrance to a room' },
            { word: 'WINDOW', hint: 'Glass opening in a wall' },
            { word: 'LAMP', hint: 'Device that provides light' },
            { word: 'MIRROR', hint: 'Reflective glass surface' },
            { word: 'CLOCK', hint: 'Device that shows time' },
            { word: 'PILLOW', hint: 'Soft cushion for your head' },
            { word: 'BLANKET', hint: 'Covering to keep warm' },
            { word: 'SPOON', hint: 'Eating utensil for soup' },
            
            // Emotions & Feelings
            { word: 'HAPPY', hint: 'Feeling of joy' },
            { word: 'ANGRY', hint: 'Feeling of rage' },
            { word: 'SCARED', hint: 'Feeling of fear' },
            { word: 'LOVE', hint: 'Strong affection' },
            { word: 'PEACE', hint: 'State of calm' },
            { word: 'HOPE', hint: 'Feeling of expectation' },
            { word: 'DREAM', hint: 'Images during sleep' },
            { word: 'SMILE', hint: 'Happy facial expression' },
            { word: 'LAUGH', hint: 'Sound of amusement' },
            { word: 'CRY', hint: 'Shed tears' },
            
            // Time & Seasons
            { word: 'DAY', hint: 'Period of 24 hours' },
            { word: 'NIGHT', hint: 'Dark period when we sleep' },
            { word: 'MORNING', hint: 'Early part of the day' },
            { word: 'EVENING', hint: 'End of the day' },
            { word: 'SPRING', hint: 'Season when flowers bloom' },
            { word: 'SUMMER', hint: 'Hottest season' },
            { word: 'AUTUMN', hint: 'Season when leaves fall' },
            { word: 'WINTER', hint: 'Coldest season' },
            { word: 'YEAR', hint: 'Period of 365 days' },
            { word: 'MONTH', hint: 'Period of about 30 days' },
            
            // Actions & Verbs
            { word: 'RUN', hint: 'Move quickly on foot' },
            { word: 'WALK', hint: 'Move at regular pace' },
            { word: 'JUMP', hint: 'Spring off the ground' },
            { word: 'SWIM', hint: 'Move through water' },
            { word: 'FLY', hint: 'Move through the air' },
            { word: 'SLEEP', hint: 'Rest with eyes closed' },
            { word: 'EAT', hint: 'Consume food' },
            { word: 'DRINK', hint: 'Consume liquid' },
            { word: 'WRITE', hint: 'Mark letters on paper' },
            { word: 'READ', hint: 'Look at and understand text' },
            
            // Challenging Words
            { word: 'CREATIVE', hint: 'Having original ideas' },
            { word: 'MYSTERY', hint: 'Something unexplained' },
            { word: 'ADVENTURE', hint: 'Exciting journey' },
            { word: 'TREASURE', hint: 'Valuable hidden item' },
            { word: 'RAINBOW', hint: 'Colorful arc in the sky' },
            { word: 'THUNDER', hint: 'Loud sound during storms' },
            { word: 'LIGHTNING', hint: 'Electric flash in sky' },
            { word: 'VOLCANO', hint: 'Mountain that erupts lava' },
            { word: 'DINOSAUR', hint: 'Extinct giant reptile' },
            { word: 'CHOCOLATE', hint: 'Sweet brown confection' },
            
            // Science & Space
            { word: 'STAR', hint: 'Bright point of light in night sky' },
            { word: 'MOON', hint: 'Earth\'s natural satellite' },
            { word: 'SUN', hint: 'Star at center of solar system' },
            { word: 'EARTH', hint: 'Our home planet' },
            { word: 'SPACE', hint: 'Vast area beyond atmosphere' },
            { word: 'ENERGY', hint: 'Power to do work' },
            { word: 'GRAVITY', hint: 'Force that pulls objects down' },
            { word: 'MAGNET', hint: 'Object that attracts metal' },
            { word: 'CRYSTAL', hint: 'Clear geometric mineral' },
            { word: 'ELEMENT', hint: 'Basic chemical substance' }
        ];

        function setupAnagramGame() {
            anagramScore = 0;
            anagramRound = 1;
            playerAnswer = [];
            nextAnagram();
        }

        function nextAnagram() {
            const wordData = anagramWords[Math.floor(Math.random() * anagramWords.length)];
            currentWord = wordData.word;
            currentHint = wordData.hint;
            
            // Scramble the word
            const scrambled = currentWord.split('').sort(() => Math.random() - 0.5).join('');
            
            document.getElementById('anagram-scrambled').textContent = scrambled;
            document.getElementById('anagram-hint').textContent = currentHint;
            document.getElementById('anagram-score').textContent = anagramScore;
            document.getElementById('anagram-round').textContent = anagramRound;
            
            // Create letter buttons
            const lettersContainer = document.getElementById('anagram-letters');
            lettersContainer.innerHTML = '';
            
            scrambled.split('').forEach((letter, index) => {
                const btn = document.createElement('button');
                btn.className = 'anagram-letter bg-gray-200 hover:bg-gray-300 dark:bg-gray-600 dark:hover:bg-gray-500 text-gray-800 dark:text-white';
                btn.textContent = letter;
                btn.onclick = () => addLetter(letter, index);
                btn.id = `letter-${index}`;
                lettersContainer.appendChild(btn);
            });
            
            playerAnswer = [];
            updateAnagramAnswer();
            document.getElementById('anagram-result').textContent = '';
        }

        function addLetter(letter, index) {
            playerAnswer.push({ letter, index });
            document.getElementById(`letter-${index}`).style.display = 'none';
            updateAnagramAnswer();
        }

        function updateAnagramAnswer() {
            const answerDiv = document.getElementById('anagram-answer');
            answerDiv.innerHTML = playerAnswer.map((item, idx) => 
                `<span class="inline-block bg-primary text-white px-3 py-1 m-1 rounded cursor-pointer" onclick="removeLetter(${idx})">${item.letter}</span>`
            ).join('');
        }

        function removeLetter(answerIndex) {
            const removed = playerAnswer.splice(answerIndex, 1)[0];
            document.getElementById(`letter-${removed.index}`).style.display = 'inline-block';
            updateAnagramAnswer();
        }

        function clearAnagramAnswer() {
            playerAnswer.forEach(item => {
                document.getElementById(`letter-${item.index}`).style.display = 'inline-block';
            });
            playerAnswer = [];
            updateAnagramAnswer();
        }

        function checkAnagramAnswer() {
            const answer = playerAnswer.map(item => item.letter).join('');
            
            if (answer === currentWord) {
                anagramScore += 10;
                anagramRound++;
                document.getElementById('anagram-result').textContent = 'üéâ Correct!';
                document.getElementById('anagram-result').style.color = '#16a34a';
                
                setTimeout(() => {
                    nextAnagram();
                }, 2000);
            } else {
                document.getElementById('anagram-result').textContent = '‚ùå Try again!';
                document.getElementById('anagram-result').style.color = '#dc2626';
            }
        }

        // Sliding Puzzle Game
        let slidingBoard = [];
        let slidingMoves = 0;
        let slidingStartTime = null;
        let slidingInterval = null;
        let emptyPosition = { row: 3, col: 3 };

        function setupSlidingPuzzle() {
            resetSlidingPuzzle();
        }

        function resetSlidingPuzzle() {
            // Initialize solved puzzle
            slidingBoard = [];
            for (let i = 0; i < 4; i++) {
                slidingBoard[i] = [];
                for (let j = 0; j < 4; j++) {
                    slidingBoard[i][j] = i * 4 + j + 1;
                }
            }
            slidingBoard[3][3] = 0; // Empty space
            emptyPosition = { row: 3, col: 3 };
            
            slidingMoves = 0;
            slidingStartTime = null;
            clearInterval(slidingInterval);
            
            updateSlidingDisplay();
            renderSlidingPuzzle();
        }

        function shuffleSlidingPuzzle() {
            // Shuffle by making random valid moves
            for (let i = 0; i < 1000; i++) {
                const validMoves = getValidSlidingMoves();
                if (validMoves.length > 0) {
                    const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                    moveSlidingTile(randomMove.row, randomMove.col, false);
                }
            }
            
            slidingMoves = 0;
            slidingStartTime = Date.now();
            slidingInterval = setInterval(updateSlidingTime, 1000);
            updateSlidingDisplay();
            renderSlidingPuzzle();
        }

        function getValidSlidingMoves() {
            const moves = [];
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            
            directions.forEach(([dr, dc]) => {
                const newRow = emptyPosition.row + dr;
                const newCol = emptyPosition.col + dc;
                
                if (newRow >= 0 && newRow < 4 && newCol >= 0 && newCol < 4) {
                    moves.push({ row: newRow, col: newCol });
                }
            });
            
            return moves;
        }

        function moveSlidingTile(row, col, countMove = true) {
            const rowDiff = Math.abs(row - emptyPosition.row);
            const colDiff = Math.abs(col - emptyPosition.col);
            
            // Check if the move is valid (adjacent to empty space)
            if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
                // Swap tile with empty space
                slidingBoard[emptyPosition.row][emptyPosition.col] = slidingBoard[row][col];
                slidingBoard[row][col] = 0;
                emptyPosition = { row, col };
                
                if (countMove) {
                    slidingMoves++;
                    if (!slidingStartTime) {
                        slidingStartTime = Date.now();
                        slidingInterval = setInterval(updateSlidingTime, 1000);
                    }
                    updateSlidingDisplay();
                    
                    if (checkSlidingWin()) {
                        clearInterval(slidingInterval);
                        setTimeout(() => {
                            document.getElementById('sliding-result').textContent = 'üéâ Puzzle solved!';
                        }, 100);
                    }
                }
                
                renderSlidingPuzzle();
                return true;
            }
            return false;
        }

        function checkSlidingWin() {
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const expectedValue = (i === 3 && j === 3) ? 0 : i * 4 + j + 1;
                    if (slidingBoard[i][j] !== expectedValue) {
                        return false;
                    }
                }
            }
            return true;
        }

        function renderSlidingPuzzle() {
            const grid = document.getElementById('sliding-grid');
            grid.innerHTML = '';
            grid.style.display = 'grid';
            grid.style.gridTemplateColumns = 'repeat(4, 60px)';
            grid.style.gap = '2px';
            
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const tile = document.createElement('div');
                    const value = slidingBoard[i][j];
                    
                    if (value === 0) {
                        tile.className = 'w-15 h-15 bg-gray-400 dark:bg-gray-600 rounded';
                    } else {
                        tile.className = 'sliding-tile cursor-pointer hover:bg-opacity-80';
                        tile.textContent = value;
                        tile.onclick = () => moveSlidingTile(i, j);
                    }
                    
                    tile.style.width = '60px';
                    tile.style.height = '60px';
                    
                    grid.appendChild(tile);
                }
            }
        }

        function updateSlidingDisplay() {
            document.getElementById('sliding-moves').textContent = slidingMoves;
        }

        function updateSlidingTime() {
            if (!slidingStartTime) return;
            
            const elapsed = Math.floor((Date.now() - slidingStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('sliding-time').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Enhanced Math Quiz System
        let mathScore = 0;
        let mathStreak = 0;
        let mathTime = 0;
        let mathInterval;
        let mathDifficulty = 'medium';
        let mathCategory = 'arithmetic';
        let mathMode = 'timed';
        let currentMathAnswer = 0;
        let mathGameRunning = false;
        let mathQuestionsAnswered = 0;
        let mathCorrectAnswers = 0;
        let mathWrongAnswers = 0;

        // Math problem generators by category
        const mathGenerators = {
            arithmetic: generateArithmeticProblem,
            fractions: generateFractionProblem,
            percentages: generatePercentageProblem,
            algebra: generateAlgebraProblem,
            geometry: generateGeometryProblem,
            'word-problems': generateWordProblem,
            'mental-math': generateMentalMathProblem,
            mixed: generateMixedProblem
        };

        function setupMathQuiz() {
            mathScore = 0;
            mathStreak = 0;
            mathTime = 0;
            mathGameRunning = false;
            mathQuestionsAnswered = 0;
            mathCorrectAnswers = 0;
            mathWrongAnswers = 0;
            
            setMathCategory('arithmetic');
            updateMathDisplay();
            clearInterval(mathInterval);
        }

        function setMathCategory(category) {
            mathCategory = category;
            
            // Update button appearance
            document.querySelectorAll('.math-category-btn').forEach(btn => {
                btn.classList.remove('ring-2', 'ring-white');
            });
            event.target?.classList.add('ring-2', 'ring-white');
            
            // Update current category display
            const categoryNames = {
                'arithmetic': 'Arithmetic',
                'fractions': 'Fractions',
                'percentages': 'Percentages',
                'algebra': 'Algebra',
                'geometry': 'Geometry',
                'word-problems': 'Word Problems',
                'mental-math': 'Mental Math',
                'mixed': 'Mixed'
            };
            document.getElementById('current-math-category').textContent = categoryNames[category];
        }

        function setMathDifficulty() {
            mathDifficulty = document.getElementById('math-difficulty').value;
        }

        function startMathQuiz() {
            if (mathGameRunning) return;
            
            mathGameRunning = true;
            mathScore = 0;
            mathStreak = 0;
            mathTime = 0;
            mathQuestionsAnswered = 0;
            mathCorrectAnswers = 0;
            mathWrongAnswers = 0;
            
            mathMode = document.getElementById('math-mode').value;
            
            document.getElementById('math-start-btn').style.display = 'none';
            document.getElementById('math-result').textContent = '';
            document.getElementById('math-results').classList.add('hidden');
            
            if (mathMode === 'timed') {
                mathTime = 60; // Countdown for timed mode
                mathInterval = setInterval(() => {
                    mathTime--;
                    document.getElementById('math-time').textContent = mathTime + 's';
                    if (mathTime <= 0) {
                        endMathQuiz();
                    }
                }, 1000);
            } else {
                mathInterval = setInterval(() => {
                    mathTime++;
                    document.getElementById('math-time').textContent = mathTime + 's';
                }, 1000);
            }
            
            generateMathProblem();
        }

        function generateMathProblem() {
            if (!mathGameRunning) return;
            
            const generator = mathGenerators[mathCategory];
            if (generator) {
                generator();
            } else {
                generateArithmeticProblem(); // fallback
            }
        }

        function generateArithmeticProblem() {
            const ranges = {
                easy: { min: 1, max: 20 },
                medium: { min: 1, max: 100 },
                hard: { min: 10, max: 500 },
                expert: { min: 50, max: 1000 }
            };
            
            const range = ranges[mathDifficulty];
            const operations = ['+', '-', '√ó', '√∑'];
            const operation = operations[Math.floor(Math.random() * operations.length)];
            
            let a, b, problem, answer;
            
            do {
                a = Math.floor(Math.random() * (range.max - range.min)) + range.min;
                b = Math.floor(Math.random() * (range.max - range.min)) + range.min;
                
                switch (operation) {
                    case '+':
                        answer = a + b;
                        problem = `${a} + ${b}`;
                        break;
                    case '-':
                        if (a < b) [a, b] = [b, a];
                        answer = a - b;
                        problem = `${a} - ${b}`;
                        break;
                    case '√ó':
                        answer = a * b;
                        problem = `${a} √ó ${b}`;
                        break;
                    case '√∑':
                        answer = a;
                        a = a * b;
                        problem = `${a} √∑ ${b}`;
                        break;
                }
            } while (answer > 10000 || answer < 0);
            
            showMathProblem(problem, answer);
        }

        function generateFractionProblem() {
            const difficultyMods = {
                easy: { maxNum: 10, maxDen: 10 },
                medium: { maxNum: 20, maxDen: 20 },
                hard: { maxNum: 50, maxDen: 50 },
                expert: { maxNum: 100, maxDen: 100 }
            };
            
            const mod = difficultyMods[mathDifficulty];
            const operations = ['+', '-', '√ó', '√∑'];
            const operation = operations[Math.floor(Math.random() * operations.length)];
            
            let num1 = Math.floor(Math.random() * mod.maxNum) + 1;
            let den1 = Math.floor(Math.random() * mod.maxDen) + 2;
            let num2 = Math.floor(Math.random() * mod.maxNum) + 1;
            let den2 = Math.floor(Math.random() * mod.maxDen) + 2;
            
            let problem, answer;
            
            switch (operation) {
                case '+':
                    const addResult = (num1 * den2 + num2 * den1) / (den1 * den2);
                    problem = `${num1}/${den1} + ${num2}/${den2}`;
                    answer = Math.round(addResult * 100) / 100;
                    break;
                case '-':
                    const subResult = (num1 * den2 - num2 * den1) / (den1 * den2);
                    problem = `${num1}/${den1} - ${num2}/${den2}`;
                    answer = Math.round(subResult * 100) / 100;
                    break;
                case '√ó':
                    const multResult = (num1 * num2) / (den1 * den2);
                    problem = `${num1}/${den1} √ó ${num2}/${den2}`;
                    answer = Math.round(multResult * 100) / 100;
                    break;
                case '√∑':
                    const divResult = (num1 * den2) / (den1 * num2);
                    problem = `${num1}/${den1} √∑ ${num2}/${den2}`;
                    answer = Math.round(divResult * 100) / 100;
                    break;
            }
            
            showMathProblem(problem, answer);
        }

        function generatePercentageProblem() {
            const problems = [
                () => {
                    const whole = Math.floor(Math.random() * 1000) + 100;
                    const percent = Math.floor(Math.random() * 100) + 1;
                    return [`${percent}% of ${whole}`, Math.round(whole * percent / 100)];
                },
                () => {
                    const part = Math.floor(Math.random() * 200) + 10;
                    const whole = part + Math.floor(Math.random() * 300) + 50;
                    return [`${part} is what % of ${whole}?`, Math.round((part / whole) * 100)];
                },
                () => {
                    const original = Math.floor(Math.random() * 500) + 100;
                    const percent = Math.floor(Math.random() * 50) + 10;
                    const result = original + (original * percent / 100);
                    return [`${original} increased by ${percent}%`, Math.round(result)];
                }
            ];
            
            const problemFunc = problems[Math.floor(Math.random() * problems.length)];
            const [problem, answer] = problemFunc();
            showMathProblem(problem, answer);
        }

        function generateAlgebraProblem() {
            const problems = [
                () => {
                    const x = Math.floor(Math.random() * 20) + 1;
                    const a = Math.floor(Math.random() * 10) + 1;
                    const b = a * x;
                    return [`${a}x = ${b}`, x];
                },
                () => {
                    const x = Math.floor(Math.random() * 15) + 1;
                    const a = Math.floor(Math.random() * 5) + 2;
                    const b = Math.floor(Math.random() * 20) + 5;
                    const result = a * x + b;
                    return [`${a}x + ${b} = ${result}`, x];
                },
                () => {
                    const x = Math.floor(Math.random() * 10) + 1;
                    const a = Math.floor(Math.random() * 5) + 2;
                    const b = Math.floor(Math.random() * 20) + 5;
                    const result = a * x - b;
                    return [`${a}x - ${b} = ${result}`, x];
                }
            ];
            
            const problemFunc = problems[Math.floor(Math.random() * problems.length)];
            const [problem, answer] = problemFunc();
            showMathProblem(`Solve for x: ${problem}`, answer);
        }

        function generateGeometryProblem() {
            const problems = [
                () => {
                    const side = Math.floor(Math.random() * 20) + 3;
                    return [`Area of square with side ${side}`, side * side];
                },
                () => {
                    const length = Math.floor(Math.random() * 20) + 3;
                    const width = Math.floor(Math.random() * 20) + 3;
                    return [`Area of rectangle ${length} √ó ${width}`, length * width];
                },
                () => {
                    const radius = Math.floor(Math.random() * 10) + 2;
                    return [`Area of circle with radius ${radius} (use œÄ ‚âà 3.14)`, Math.round(3.14 * radius * radius)];
                },
                () => {
                    const base = Math.floor(Math.random() * 20) + 5;
                    const height = Math.floor(Math.random() * 15) + 3;
                    return [`Area of triangle: base ${base}, height ${height}`, Math.round(0.5 * base * height)];
                }
            ];
            
            const problemFunc = problems[Math.floor(Math.random() * problems.length)];
            const [problem, answer] = problemFunc();
            showMathProblem(problem, answer);
        }

        function generateWordProblem() {
            const problems = [
                () => {
                    const apples = Math.floor(Math.random() * 20) + 5;
                    const eaten = Math.floor(Math.random() * apples);
                    return [`You have ${apples} apples. You eat ${eaten}. How many are left?`, apples - eaten];
                },
                () => {
                    const speed = Math.floor(Math.random() * 50) + 30;
                    const time = Math.floor(Math.random() * 5) + 2;
                    return [`A car travels ${speed} mph for ${time} hours. Distance traveled?`, speed * time];
                },
                () => {
                    const price = Math.floor(Math.random() * 50) + 10;
                    const discount = Math.floor(Math.random() * 30) + 10;
                    const final = price - (price * discount / 100);
                    return [`Item costs $${price}. ${discount}% discount. Final price?`, Math.round(final)];
                },
                () => {
                    const students = Math.floor(Math.random() * 30) + 20;
                    const perGroup = Math.floor(Math.random() * 6) + 3;
                    return [`${students} students in groups of ${perGroup}. How many groups?`, Math.floor(students / perGroup)];
                }
            ];
            
            const problemFunc = problems[Math.floor(Math.random() * problems.length)];
            const [problem, answer] = problemFunc();
            showMathProblem(problem, answer);
        }

        function generateMentalMathProblem() {
            const problems = [
                () => {
                    const base = Math.floor(Math.random() * 9) + 1;
                    const mult = Math.pow(10, Math.floor(Math.random() * 3) + 1);
                    return [`${base} √ó ${mult}`, base * mult];
                },
                () => {
                    const num = Math.floor(Math.random() * 900) + 100;
                    return [`${num} √∑ 10`, num / 10];
                },
                () => {
                    const a = Math.floor(Math.random() * 50) + 25;
                    const b = Math.floor(Math.random() * 50) + 25;
                    return [`${a} + ${b}`, a + b];
                },
                () => {
                    const base = Math.floor(Math.random() * 15) + 5;
                    return [`${base}¬≤`, base * base];
                }
            ];
            
            const problemFunc = problems[Math.floor(Math.random() * problems.length)];
            const [problem, answer] = problemFunc();
            showMathProblem(problem, answer);
        }

        function generateMixedProblem() {
            const categories = ['arithmetic', 'fractions', 'percentages', 'algebra', 'geometry', 'word-problems', 'mental-math'];
            const randomCategory = categories[Math.floor(Math.random() * categories.length)];
            mathGenerators[randomCategory]();
        }

        function showMathProblem(problem, answer) {
            currentMathAnswer = answer;
            document.getElementById('math-problem').textContent = problem + ' = ?';
            
            // Generate options
            const options = [answer];
            const range = Math.max(10, Math.abs(answer * 0.5));
            
            while (options.length < 4) {
                let wrongAnswer;
                if (answer % 1 === 0) { // Integer answer
                    wrongAnswer = answer + Math.floor(Math.random() * range * 2) - range;
                } else { // Decimal answer
                    wrongAnswer = Math.round((answer + (Math.random() * range * 2) - range) * 100) / 100;
                }
                
                if (wrongAnswer !== answer && wrongAnswer > 0 && !options.includes(wrongAnswer)) {
                    options.push(wrongAnswer);
                }
            }
            
            // Shuffle options
            options.sort(() => Math.random() - 0.5);
            
            const optionsContainer = document.getElementById('math-options');
            optionsContainer.innerHTML = options.map(option => 
                `<button class="quiz-option" onclick="checkMathAnswer(${option})">${option}</button>`
            ).join('');
        }

        function checkMathAnswer(selectedAnswer) {
            if (!mathGameRunning) return;
            
            mathQuestionsAnswered++;
            
            const options = document.querySelectorAll('.quiz-option');
            
            options.forEach(option => {
                const value = parseFloat(option.textContent);
                if (Math.abs(value - currentMathAnswer) < 0.01) { // Allow for floating point precision
                    option.classList.add('correct');
                } else if (Math.abs(value - selectedAnswer) < 0.01 && Math.abs(value - currentMathAnswer) >= 0.01) {
                    option.classList.add('incorrect');
                }
                option.onclick = null; // Disable further clicks
            });
            
            if (Math.abs(selectedAnswer - currentMathAnswer) < 0.01) {
                mathCorrectAnswers++;
                mathStreak++;
                const points = Math.max(1, 10 + mathStreak);
                mathScore += points;
                document.getElementById('math-result').textContent = `‚úÖ Correct! +${points} pts`;
                document.getElementById('math-result').style.color = '#16a34a';
            } else {
                mathWrongAnswers++;
                mathStreak = 0;
                document.getElementById('math-result').textContent = `‚ùå Wrong! Answer: ${currentMathAnswer}`;
                document.getElementById('math-result').style.color = '#dc2626';
            }
            
            updateMathDisplay();
            
            // Check if sprint mode is complete
            if (mathMode === 'sprint' && mathQuestionsAnswered >= 10) {
                endMathQuiz();
                return;
            }
            
            setTimeout(() => {
                if (mathGameRunning) {
                    generateMathProblem();
                    document.getElementById('math-result').textContent = '';
                }
            }, 1500);
        }

        function endMathQuiz() {
            mathGameRunning = false;
            clearInterval(mathInterval);
            
            // Show results
            document.getElementById('final-math-score').textContent = mathScore;
            document.getElementById('final-math-correct').textContent = mathCorrectAnswers;
            document.getElementById('final-math-wrong').textContent = mathWrongAnswers;
            
            const accuracy = mathQuestionsAnswered > 0 ? Math.round((mathCorrectAnswers / mathQuestionsAnswered) * 100) : 0;
            document.getElementById('final-math-accuracy').textContent = accuracy + '%';
            
            // Performance rating
            let rating = '';
            let tips = '';
            
            if (accuracy >= 90 && mathScore >= 200) {
                rating = 'üèÜ Math Master!';
                tips = 'Outstanding! You have excellent math skills.';
            } else if (accuracy >= 80 && mathScore >= 150) {
                rating = '‚≠ê Great Job!';
                tips = 'Well done! Keep practicing to improve even more.';
            } else if (accuracy >= 70 && mathScore >= 100) {
                rating = 'üëç Good Work';
                tips = 'Good progress! Try different categories to improve.';
            } else if (accuracy >= 50) {
                rating = 'üìà Keep Learning';
                tips = 'You\'re improving! Focus on accuracy first, then speed.';
            } else {
                rating = 'üå± Practice More';
                tips = 'Keep practicing! Try easier difficulties to build confidence.';
            }
            
            document.getElementById('math-performance-rating').textContent = rating;
            document.getElementById('math-performance-tips').textContent = tips;
            
            document.getElementById('math-results').classList.remove('hidden');
            document.getElementById('math-start-btn').style.display = 'inline-block';
        }

        function updateMathDisplay() {
            document.getElementById('math-score').textContent = mathScore;
            document.getElementById('math-streak').textContent = mathStreak;
            
            if (mathMode === 'timed') {
                document.getElementById('math-time').textContent = mathTime + 's';
            } else if (mathMode === 'sprint') {
                document.getElementById('math-time').textContent = `${mathQuestionsAnswered}/10`;
            } else {
                document.getElementById('math-time').textContent = mathTime + 's';
            }
        }

        // Number Sequence Game
        let sequenceLevel = 1;
        let sequenceBest = 1;
        let currentSequence = [];
        let playerSequence = [];
        let sequencePhase = 'ready'; // 'ready', 'showing', 'input'
        let sequenceTimeout;

        function setupNumberSequence() {
            try {
                sequenceBest = parseInt(localStorage.getItem('sequenceBest')) || 1;
            } catch (error) {
                sequenceBest = 1;
            }
            resetSequenceGame();
        }

        function resetSequenceGame() {
            sequenceLevel = 1;
            currentSequence = [];
            playerSequence = [];
            sequencePhase = 'ready';
            clearTimeout(sequenceTimeout);
            
            document.getElementById('sequence-level').textContent = sequenceLevel;
            document.getElementById('sequence-best').textContent = sequenceBest;
            document.getElementById('sequence-status').textContent = 'Click Start to begin';
            document.getElementById('sequence-numbers').textContent = 'Ready?';
            document.getElementById('sequence-input').classList.add('hidden');
            document.getElementById('sequence-start-btn').style.display = 'inline-block';
        }

        function startSequenceGame() {
            sequenceLevel = 1;
            generateNewSequence();
        }

        function generateNewSequence() {
            currentSequence = [];
            playerSequence = [];
            
            // Generate sequence of numbers
            for (let i = 0; i < sequenceLevel + 2; i++) {
                currentSequence.push(Math.floor(Math.random() * 9) + 1);
            }
            
            document.getElementById('sequence-level').textContent = sequenceLevel;
            document.getElementById('sequence-start-btn').style.display = 'none';
            document.getElementById('sequence-input').classList.add('hidden');
            
            showSequence();
        }

        function showSequence() {
            sequencePhase = 'showing';
            document.getElementById('sequence-status').textContent = 'Memorize this sequence:';
            
            let index = 0;
            
            function showNextNumber() {
                if (index < currentSequence.length) {
                    document.getElementById('sequence-numbers').textContent = currentSequence[index];
                    index++;
                    sequenceTimeout = setTimeout(() => {
                        document.getElementById('sequence-numbers').textContent = '‚Ä¢';
                        sequenceTimeout = setTimeout(showNextNumber, 500);
                    }, 800);
                } else {
                    // Sequence shown, time for input
                    startSequenceInput();
                }
            }
            
            showNextNumber();
        }

        function startSequenceInput() {
            sequencePhase = 'input';
            document.getElementById('sequence-status').textContent = 'Click the numbers in order:';
            document.getElementById('sequence-numbers').textContent = 'Your turn!';
            
            // Generate number buttons
            const buttonsContainer = document.getElementById('sequence-buttons');
            buttonsContainer.innerHTML = '';
            
            for (let i = 1; i <= 9; i++) {
                const btn = document.createElement('button');
                btn.className = 'w-12 h-12 bg-primary hover:bg-primary-dark text-white font-bold rounded transition-colors';
                btn.textContent = i;
                btn.onclick = () => selectSequenceNumber(i);
                buttonsContainer.appendChild(btn);
            }
            
            document.getElementById('sequence-input').classList.remove('hidden');
            playerSequence = [];
        }

        function selectSequenceNumber(number) {
            if (sequencePhase !== 'input') return;
            
            playerSequence.push(number);
            
            // Check if the selection is correct so far
            if (playerSequence[playerSequence.length - 1] !== currentSequence[playerSequence.length - 1]) {
                // Wrong number
                sequenceGameOver();
                return;
            }
            
            // Update display to show progress
            document.getElementById('sequence-numbers').textContent = playerSequence.join(' ');
            
            // Check if sequence is complete
            if (playerSequence.length === currentSequence.length) {
                // Correct sequence completed!
                sequenceLevel++;
                
                if (sequenceLevel > sequenceBest) {
                    sequenceBest = sequenceLevel;
                    try {
                        localStorage.setItem('sequenceBest', sequenceBest.toString());
                    } catch (error) {}
                    document.getElementById('sequence-best').textContent = sequenceBest;
                }
                
                document.getElementById('sequence-status').textContent = 'üéâ Correct! Next level...';
                document.getElementById('sequence-input').classList.add('hidden');
                
                sequenceTimeout = setTimeout(() => {
                    generateNewSequence();
                }, 2000);
            }
        }

        function sequenceGameOver() {
            sequencePhase = 'ready';
            document.getElementById('sequence-status').textContent = `Game Over! You reached level ${sequenceLevel}`;
            document.getElementById('sequence-numbers').textContent = `Correct: ${currentSequence.join(' ')}`;
            document.getElementById('sequence-input').classList.add('hidden');
            document.getElementById('sequence-start-btn').style.display = 'inline-block';
        }

        // Reflex Test Game
        let reflexScore = 0;
        let reflexHits = 0;
        let reflexMisses = 0;
        let reflexGameRunning = false;
        let reflexInterval;
        let targetShapeType = 'circle';
        let targetShapeColor = '#3B82F6';
        let currentTestShape = { type: 'circle', color: '#EF4444' };
        let shapesMatch = false;

        function setupReflexTest() {
            reflexScore = 0;
            reflexHits = 0;
            reflexMisses = 0;
            reflexGameRunning = false;
            shapesMatch = false;
            
            generateNewTargetShape();
            generateNewTestShape();
            updateReflexDisplay();
        }

        function generateNewTargetShape() {
            const shapes = ['circle', 'square', 'triangle'];
            const colors = ['#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6'];
            
            targetShapeType = shapes[Math.floor(Math.random() * shapes.length)];
            targetShapeColor = colors[Math.floor(Math.random() * colors.length)];
            
            const targetElement = document.getElementById('target-shape');
            targetElement.style.backgroundColor = targetShapeColor;
            
            // Apply shape
            if (targetShapeType === 'circle') {
                targetElement.style.borderRadius = '50%';
            } else if (targetShapeType === 'square') {
                targetElement.style.borderRadius = '0';
            } else if (targetShapeType === 'triangle') {
                targetElement.style.borderRadius = '0';
                targetElement.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
            }
        }

        function generateNewTestShape() {
            const shapes = ['circle', 'square', 'triangle'];
            const colors = ['#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6'];
            
            currentTestShape.type = shapes[Math.floor(Math.random() * shapes.length)];
            currentTestShape.color = colors[Math.floor(Math.random() * colors.length)];
            
            const testElement = document.getElementById('test-shape');
            testElement.style.backgroundColor = currentTestShape.color;
            
            // Apply shape
            if (currentTestShape.type === 'circle') {
                testElement.style.borderRadius = '50%';
                testElement.style.clipPath = 'none';
            } else if (currentTestShape.type === 'square') {
                testElement.style.borderRadius = '0';
                testElement.style.clipPath = 'none';
            } else if (currentTestShape.type === 'triangle') {
                testElement.style.borderRadius = '0';
                testElement.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
            }
            
            // Check if shapes match
            shapesMatch = (currentTestShape.type === targetShapeType && 
                          currentTestShape.color === targetShapeColor);
        }

        function startReflexTest() {
            if (reflexGameRunning) return;
            
            reflexGameRunning = true;
            reflexScore = 0;
            reflexHits = 0;
            reflexMisses = 0;
            
            document.getElementById('reflex-start-btn').style.display = 'none';
            document.getElementById('reflex-result').textContent = '';
            
            updateReflexDisplay();
            
            // Start the game loop
            reflexInterval = setInterval(() => {
                generateNewTestShape();
                
                // Automatically count as miss if shapes matched and user didn't click
                if (shapesMatch) {
                    setTimeout(() => {
                        if (reflexGameRunning && shapesMatch) {
                            reflexMisses++;
                            updateReflexDisplay();
                        }
                    }, 1500); // Give 1.5 seconds to react
                }
            }, 2000);
            
            // End game after 30 seconds
            setTimeout(() => {
                endReflexTest();
            }, 30000);
        }

        function handleReflexClick() {
            if (!reflexGameRunning) return;
            
            if (shapesMatch) {
                // Correct click!
                reflexHits++;
                reflexScore += 10;
                document.getElementById('reflex-result').textContent = '‚úÖ Hit!';
                document.getElementById('reflex-result').style.color = '#16a34a';
                shapesMatch = false; // Prevent double counting
            } else {
                // Wrong click
                reflexMisses++;
                document.getElementById('reflex-result').textContent = '‚ùå Miss!';
                document.getElementById('reflex-result').style.color = '#dc2626';
            }
            
            updateReflexDisplay();
            
            // Clear result after short delay
            setTimeout(() => {
                if (reflexGameRunning) {
                    document.getElementById('reflex-result').textContent = '';
                }
            }, 1000);
        }

        function endReflexTest() {
            reflexGameRunning = false;
            clearInterval(reflexInterval);
            
            const accuracy = reflexHits + reflexMisses > 0 ? 
                Math.round((reflexHits / (reflexHits + reflexMisses)) * 100) : 0;
            
            document.getElementById('reflex-result').textContent = 
                `Game Over! Accuracy: ${accuracy}%`;
            document.getElementById('reflex-start-btn').style.display = 'inline-block';
        }

        function resetReflexTest() {
            reflexGameRunning = false;
            clearInterval(reflexInterval);
            
            reflexScore = 0;
            reflexHits = 0;
            reflexMisses = 0;
            
            updateReflexDisplay();
            document.getElementById('reflex-result').textContent = '';
            document.getElementById('reflex-start-btn').style.display = 'inline-block';
            
            generateNewTargetShape();
            generateNewTestShape();
        }

        function updateReflexDisplay() {
            document.getElementById('reflex-score').textContent = reflexScore;
            document.getElementById('reflex-hits').textContent = reflexHits;
            document.getElementById('reflex-misses').textContent = reflexMisses;
        }

        // Memory Cards Game (Simon Says style)
        let cardsLevel = 1;
        let cardsBest = 1;
        let cardsSequence = [];
        let cardsPlayerSequence = [];
        let cardsPhase = 'ready'; // 'ready', 'showing', 'input'
        let cardsCurrentStep = 0;
        let cardsTimeout;

        function setupMemoryCards() {
            try {
                cardsBest = parseInt(localStorage.getItem('cardsBest')) || 1;
            } catch (error) {
                cardsBest = 1;
            }
            resetMemoryCards();
        }

        function resetMemoryCards() {
            cardsLevel = 1;
            cardsSequence = [];
            cardsPlayerSequence = [];
            cardsPhase = 'ready';
            cardsCurrentStep = 0;
            clearTimeout(cardsTimeout);
            
            document.getElementById('cards-level').textContent = cardsLevel;
            document.getElementById('cards-best').textContent = cardsBest;
            document.getElementById('cards-status').textContent = 'Click Start to begin';
            document.getElementById('cards-start-btn').style.display = 'inline-block';
            
            // Create the 3x3 grid of cards
            createCardsGrid();
        }

        function createCardsGrid() {
            const grid = document.getElementById('cards-grid');
            grid.innerHTML = '';
            
            for (let i = 0; i < 9; i++) {
                const card = document.createElement('div');
                card.className = 'w-16 h-16 bg-primary hover:bg-primary-dark rounded-lg cursor-pointer transition-all duration-200 flex items-center justify-center';
                card.id = `card-${i}`;
                card.textContent = i + 1;
                card.style.fontSize = '20px';
                card.style.fontWeight = 'bold';
                card.style.color = 'white';
                card.onclick = () => handleCardClick(i);
                grid.appendChild(card);
            }
        }

        function startMemoryCards() {
            cardsLevel = 1;
            cardsSequence = [];
            cardsPlayerSequence = [];
            
            document.getElementById('cards-start-btn').style.display = 'none';
            document.getElementById('cards-status').textContent = 'Watch the sequence...';
            
            generateNewCardsSequence();
        }

        function generateNewCardsSequence() {
            // Add one new step to the sequence
            const newCard = Math.floor(Math.random() * 9);
            cardsSequence.push(newCard);
            
            cardsPlayerSequence = [];
            cardsCurrentStep = 0;
            cardsPhase = 'showing';
            
            document.getElementById('cards-level').textContent = cardsLevel;
            
            showCardsSequence();
        }

        function showCardsSequence() {
            if (cardsCurrentStep >= cardsSequence.length) {
                // Sequence finished, time for player input
                cardsPhase = 'input';
                document.getElementById('cards-status').textContent = 'Repeat the sequence!';
                cardsPlayerSequence = [];
                return;
            }
            
            const cardIndex = cardsSequence[cardsCurrentStep];
            const card = document.getElementById(`card-${cardIndex}`);
            
            // Highlight the card
            card.style.backgroundColor = '#F59E0B';
            card.style.transform = 'scale(1.1)';
            
            cardsTimeout = setTimeout(() => {
                // Reset card appearance
                card.style.backgroundColor = '#5D5CDE';
                card.style.transform = 'scale(1)';
                
                cardsCurrentStep++;
                
                cardsTimeout = setTimeout(() => {
                    showCardsSequence();
                }, 300);
            }, 600);
        }

        function handleCardClick(cardIndex) {
            if (cardsPhase !== 'input') return;
            
            cardsPlayerSequence.push(cardIndex);
            
            // Visual feedback for click
            const card = document.getElementById(`card-${cardIndex}`);
            card.style.backgroundColor = '#F59E0B';
            card.style.transform = 'scale(1.1)';
            
            setTimeout(() => {
                card.style.backgroundColor = '#5D5CDE';
                card.style.transform = 'scale(1)';
            }, 200);
            
            // Check if the click is correct
            const currentIndex = cardsPlayerSequence.length - 1;
            if (cardsPlayerSequence[currentIndex] !== cardsSequence[currentIndex]) {
                // Wrong card clicked
                cardsGameOver();
                return;
            }
            
            // Check if sequence is complete
            if (cardsPlayerSequence.length === cardsSequence.length) {
                // Correct sequence completed!
                cardsLevel++;
                
                if (cardsLevel > cardsBest) {
                    cardsBest = cardsLevel;
                    try {
                        localStorage.setItem('cardsBest', cardsBest.toString());
                    } catch (error) {}
                    document.getElementById('cards-best').textContent = cardsBest;
                }
                
                document.getElementById('cards-status').textContent = `Level ${cardsLevel}! Get ready...`;
                
                cardsTimeout = setTimeout(() => {
                    generateNewCardsSequence();
                }, 1500);
            }
        }

        function cardsGameOver() {
            cardsPhase = 'ready';
            document.getElementById('cards-status').textContent = `Game Over! You reached level ${cardsLevel}`;
            document.getElementById('cards-start-btn').style.display = 'inline-block';
            
            // Flash the correct sequence
            let flashIndex = 0;
            function flashCorrectSequence() {
                if (flashIndex < cardsSequence.length) {
                    const cardIndex = cardsSequence[flashIndex];
                    const card = document.getElementById(`card-${cardIndex}`);
                    
                    card.style.backgroundColor = '#EF4444';
                    
                    setTimeout(() => {
                        card.style.backgroundColor = '#5D5CDE';
                        flashIndex++;
                        setTimeout(flashCorrectSequence, 300);
                    }, 400);
                }
            }
            
            setTimeout(flashCorrectSequence, 1000);
        }

        // Breakout Game
        let breakoutCanvas, breakoutCtx;
        let breakoutBall, breakoutPaddle, breakoutBricks;
        let breakoutScore = 0;
        let breakoutLives = 3;
        let breakoutGameRunning = false;

        function setupBreakout() {
            breakoutCanvas = document.getElementById('breakout-canvas');
            if (!breakoutCanvas) return;
            
            breakoutCtx = breakoutCanvas.getContext('2d');
            initBreakout();
            
            // Touch controls
            breakoutCanvas.ontouchmove = (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = breakoutCanvas.getBoundingClientRect();
                const x = (touch.clientX - rect.left) * (breakoutCanvas.width / rect.width);
                breakoutPaddle.x = Math.max(0, Math.min(breakoutCanvas.width - breakoutPaddle.width, x - breakoutPaddle.width / 2));
            };
            
            // Mouse controls
            breakoutCanvas.onmousemove = (e) => {
                const rect = breakoutCanvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (breakoutCanvas.width / rect.width);
                breakoutPaddle.x = Math.max(0, Math.min(breakoutCanvas.width - breakoutPaddle.width, x - breakoutPaddle.width / 2));
            };
        }

        function initBreakout() {
            breakoutBall = { x: 200, y: 250, dx: 3, dy: -3, radius: 8 };
            breakoutPaddle = { x: 150, y: 280, width: 80, height: 10 };
            breakoutScore = 0;
            breakoutLives = 3;
            breakoutGameRunning = false;
            
            // Create bricks
            breakoutBricks = [];
            const brickRows = 5;
            const brickCols = 8;
            const brickWidth = 45;
            const brickHeight = 20;
            const brickPadding = 5;
            
            for (let r = 0; r < brickRows; r++) {
                for (let c = 0; c < brickCols; c++) {
                    breakoutBricks.push({
                        x: c * (brickWidth + brickPadding) + brickPadding,
                        y: r * (brickHeight + brickPadding) + 30,
                        width: brickWidth,
                        height: brickHeight,
                        destroyed: false,
                        color: `hsl(${r * 60}, 70%, 50%)`
                    });
                }
            }
            
            updateBreakoutDisplay();
            drawBreakout();
        }

        function startBreakout() {
            if (breakoutGameRunning) return;
            breakoutGameRunning = true;
            document.getElementById('breakout-status').textContent = '';
            breakoutGameLoop();
        }

        function breakoutGameLoop() {
            if (!breakoutGameRunning) return;
            
            updateBreakout();
            drawBreakout();
            
            requestAnimationFrame(breakoutGameLoop);
        }

        function updateBreakout() {
            // Move ball
            breakoutBall.x += breakoutBall.dx;
            breakoutBall.y += breakoutBall.dy;
            
            // Ball collision with walls
            if (breakoutBall.x <= 0 || breakoutBall.x >= breakoutCanvas.width) {
                breakoutBall.dx = -breakoutBall.dx;
            }
            if (breakoutBall.y <= 0) {
                breakoutBall.dy = -breakoutBall.dy;
            }
            
            // Ball falls below paddle
            if (breakoutBall.y > breakoutCanvas.height) {
                breakoutLives--;
                updateBreakoutDisplay();
                
                if (breakoutLives <= 0) {
                    breakoutGameRunning = false;
                    document.getElementById('breakout-status').textContent = 'üíÄ Game Over!';
                    return;
                } else {
                    // Reset ball position
                    breakoutBall.x = 200;
                    breakoutBall.y = 250;
                    breakoutBall.dx = 3;
                    breakoutBall.dy = -3;
                }
            }
            
            // Ball collision with paddle
            if (breakoutBall.y + breakoutBall.radius >= breakoutPaddle.y &&
                breakoutBall.x >= breakoutPaddle.x &&
                breakoutBall.x <= breakoutPaddle.x + breakoutPaddle.width) {
                
                // Change angle based on where ball hits paddle
                const hitPosition = (breakoutBall.x - breakoutPaddle.x) / breakoutPaddle.width;
                breakoutBall.dx = (hitPosition - 0.5) * 6;
                breakoutBall.dy = -Math.abs(breakoutBall.dy);
            }
            
            // Ball collision with bricks
            breakoutBricks.forEach(brick => {
                if (!brick.destroyed &&
                    breakoutBall.x >= brick.x &&
                    breakoutBall.x <= brick.x + brick.width &&
                    breakoutBall.y >= brick.y &&
                    breakoutBall.y <= brick.y + brick.height) {
                    
                    brick.destroyed = true;
                    breakoutBall.dy = -breakoutBall.dy;
                    breakoutScore += 10;
                    updateBreakoutDisplay();
                    
                    // Check if all bricks are destroyed
                    if (breakoutBricks.every(b => b.destroyed)) {
                        breakoutGameRunning = false;
                        document.getElementById('breakout-status').textContent = 'üéâ You Win!';
                    }
                }
            });
        }

        function drawBreakout() {
            breakoutCtx.clearRect(0, 0, breakoutCanvas.width, breakoutCanvas.height);
            
            // Draw ball
            breakoutCtx.fillStyle = '#F59E0B';
            breakoutCtx.beginPath();
            breakoutCtx.arc(breakoutBall.x, breakoutBall.y, breakoutBall.radius, 0, Math.PI * 2);
            breakoutCtx.fill();
            
            // Draw paddle
            breakoutCtx.fillStyle = '#5D5CDE';
            breakoutCtx.fillRect(breakoutPaddle.x, breakoutPaddle.y, breakoutPaddle.width, breakoutPaddle.height);
            
            // Draw bricks
            breakoutBricks.forEach(brick => {
                if (!brick.destroyed) {
                    breakoutCtx.fillStyle = brick.color;
                    breakoutCtx.fillRect(brick.x, brick.y, brick.width, brick.height);
                }
            });
        }

        function updateBreakoutDisplay() {
            document.getElementById('breakout-score').textContent = breakoutScore;
            document.getElementById('breakout-lives').textContent = breakoutLives;
        }

        // Catch Game
        let catchCanvas, catchCtx;
        let catchBasket, catchFallingItems, catchScore, catchLives, catchLevel;
        let catchGameRunning = false;
        let catchSpawnRate = 0.02;
        let catchBasketSpeed = 5;

        function setupCatchGame() {
            catchCanvas = document.getElementById('catch-canvas');
            if (!catchCanvas) return;
            
            catchCtx = catchCanvas.getContext('2d');
            initCatchGame();
            
            // Touch controls
            catchCanvas.ontouchmove = (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = catchCanvas.getBoundingClientRect();
                const x = (touch.clientX - rect.left) * (catchCanvas.width / rect.width);
                catchBasket.x = Math.max(0, Math.min(catchCanvas.width - catchBasket.width, x - catchBasket.width / 2));
            };
            
            catchCanvas.ontouchstart = (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = catchCanvas.getBoundingClientRect();
                const x = (touch.clientX - rect.left) * (catchCanvas.width / rect.width);
                catchBasket.x = Math.max(0, Math.min(catchCanvas.width - catchBasket.width, x - catchBasket.width / 2));
            };
            
            // Mouse controls
            catchCanvas.onmousemove = (e) => {
                if (!catchGameRunning) return;
                const rect = catchCanvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (catchCanvas.width / rect.width);
                catchBasket.x = Math.max(0, Math.min(catchCanvas.width - catchBasket.width, x - catchBasket.width / 2));
            };
            
            // Keyboard controls
            document.onkeydown = (e) => {
                if (currentGame !== 'catch-game' || !catchGameRunning) return;
                
                const key = e.key.toLowerCase();
                if ((key === 'arrowleft' || key === 'a') && catchBasket.x > 0) {
                    catchBasket.x = Math.max(0, catchBasket.x - catchBasketSpeed);
                } else if ((key === 'arrowright' || key === 'd') && catchBasket.x < catchCanvas.width - catchBasket.width) {
                    catchBasket.x = Math.min(catchCanvas.width - catchBasket.width, catchBasket.x + catchBasketSpeed);
                }
            };
        }

        function initCatchGame() {
            catchBasket = { x: 160, y: 260, width: 80, height: 20 };
            catchFallingItems = [];
            catchScore = 0;
            catchLives = 3;
            catchLevel = 1;
            catchGameRunning = false;
            catchSpawnRate = 0.02;
            
            updateCatchDisplay();
            drawCatchGame();
        }

        function startCatchGame() {
            if (catchGameRunning) return;
            catchGameRunning = true;
            document.getElementById('catch-status').textContent = '';
            catchGameLoop();
        }

        function resetCatchGame() {
            catchGameRunning = false;
            initCatchGame();
        }

        function catchGameLoop() {
            if (!catchGameRunning) return;
            
            updateCatchGame();
            drawCatchGame();
            
            requestAnimationFrame(catchGameLoop);
        }

        function updateCatchGame() {
            // Spawn falling items
            if (Math.random() < catchSpawnRate) {
                const itemTypes = ['fruit', 'fruit', 'fruit', 'bomb']; // 75% fruit, 25% bomb
                const type = itemTypes[Math.floor(Math.random() * itemTypes.length)];
                
                catchFallingItems.push({
                    x: Math.random() * (catchCanvas.width - 20),
                    y: -20,
                    width: 20,
                    height: 20,
                    type: type,
                    color: type === 'fruit' ? getRandomFruitColor() : '#333',
                    emoji: type === 'fruit' ? getRandomFruitEmoji() : 'üí£',
                    speed: 1 + Math.random() * 2
                });
            }
            
            // Update falling items
            catchFallingItems.forEach((item, index) => {
                item.y += item.speed;
                
                // Check collision with basket
                if (item.y + item.height >= catchBasket.y &&
                    item.y < catchBasket.y + catchBasket.height &&
                    item.x + item.width >= catchBasket.x &&
                    item.x < catchBasket.x + catchBasket.width) {
                    
                    if (item.type === 'fruit') {
                        catchScore += 10;
                        // Check for level up
                        if (catchScore > 0 && catchScore % 100 === 0) {
                            catchLevel++;
                            catchSpawnRate = Math.min(0.05, catchSpawnRate + 0.005); // Increase difficulty
                        }
                    } else if (item.type === 'bomb') {
                        catchLives--;
                        if (catchLives <= 0) {
                            catchGameRunning = false;
                            document.getElementById('catch-status').textContent = 'üí• Game Over!';
                        }
                    }
                    
                    catchFallingItems.splice(index, 1);
                    updateCatchDisplay();
                    return;
                }
                
                // Remove items that fall off screen
                if (item.y > catchCanvas.height + 50) {
                    if (item.type === 'fruit') {
                        // Lost a fruit - could penalize here if desired
                    }
                    catchFallingItems.splice(index, 1);
                }
            });
        }

        function getRandomFruitColor() {
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#F7DC6F', '#BB8FCE', '#F1948A'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        function getRandomFruitEmoji() {
            const fruits = ['üçé', 'üçä', 'üçå', 'üçá', 'üçì', 'ü•ù', 'üçë', 'üçí'];
            return fruits[Math.floor(Math.random() * fruits.length)];
        }

        function drawCatchGame() {
            catchCtx.clearRect(0, 0, catchCanvas.width, catchCanvas.height);
            
            // Draw basket
            catchCtx.fillStyle = '#8B4513';
            catchCtx.fillRect(catchBasket.x, catchBasket.y, catchBasket.width, catchBasket.height);
            
            // Draw basket handle/rim
            catchCtx.strokeStyle = '#654321';
            catchCtx.lineWidth = 3;
            catchCtx.beginPath();
            catchCtx.moveTo(catchBasket.x, catchBasket.y);
            catchCtx.lineTo(catchBasket.x + catchBasket.width, catchBasket.y);
            catchCtx.stroke();
            
            // Draw falling items
            catchFallingItems.forEach(item => {
                if (item.type === 'fruit') {
                    // Draw fruit as colored circle with emoji
                    catchCtx.fillStyle = item.color;
                    catchCtx.beginPath();
                    catchCtx.arc(item.x + item.width/2, item.y + item.height/2, item.width/2, 0, Math.PI * 2);
                    catchCtx.fill();
                    
                    // Draw emoji on top
                    catchCtx.font = '16px Arial';
                    catchCtx.textAlign = 'center';
                    catchCtx.fillText(item.emoji, item.x + item.width/2, item.y + item.height/2 + 5);
                } else {
                    // Draw bomb
                    catchCtx.fillStyle = item.color;
                    catchCtx.fillRect(item.x, item.y, item.width, item.height);
                    
                    // Draw emoji on top
                    catchCtx.font = '16px Arial';
                    catchCtx.textAlign = 'center';
                    catchCtx.fillStyle = 'white';
                    catchCtx.fillText(item.emoji, item.x + item.width/2, item.y + item.height/2 + 5);
                }
            });
        }

        function updateCatchDisplay() {
            document.getElementById('catch-score').textContent = catchScore;
            document.getElementById('catch-lives').textContent = catchLives;
            document.getElementById('catch-level').textContent = catchLevel;
        }

        // Enhanced Word Guess Game (5-letter words only)
        let wordScore = 0;
        let wordStreak = 0;
        let currentTargetWord = '';
        let currentGuess = '';
        let currentRow = 0;
        let maxRows = 6;
        let wordGameOver = false;
        let wordGrid = [];
        let currentWordCategory = 'general';
        let currentWordDifficulty = 'medium';
        let currentWordLength = 5;
        let hintsUsed = 0;

        // Enhanced word databases by difficulty and category
        const wordDatabases = {
            easy: {
                general: ['BOOK', 'CAKE', 'DOOR', 'FISH', 'GAME', 'HAND', 'JUMP', 'KING', 'LAMP', 'MOON', 'NOSE', 'OPEN', 'PARK', 'QUIZ', 'RAIN', 'SAND', 'TREE', 'UNIT', 'VASE', 'WALL'],
                animals: ['BEAR', 'BIRD', 'DUCK', 'FISH', 'FROG', 'GOAT', 'HAWK', 'LION', 'MICE', 'PONY'],
                colors: ['BLUE', 'GRAY', 'PINK', 'GOLD', 'LIME', 'NAVY', 'ROSE', 'SAGE', 'TEAL', 'WINE'],
                food: ['BEEF', 'CAKE', 'CORN', 'DATE', 'EGGS', 'FISH', 'HERB', 'JAM', 'KALE', 'LIME'],
                nature: ['BARK', 'CAVE', 'DIRT', 'FERN', 'GLEN', 'HILL', 'ISLE', 'LAKE', 'MOSS', 'PEAK'],
                science: ['ACID', 'ATOM', 'BEAM', 'CELL', 'DATA', 'GENE', 'HEAT', 'IRON', 'LENS', 'MASS'],
                sports: ['BALL', 'BIKE', 'DIVE', 'GAME', 'GOAL', 'JUMP', 'KICK', 'LANE', 'MEET', 'POOL']
            },
            medium: {
                general: ['APPLE', 'BEACH', 'CHAIR', 'DANCE', 'EAGLE', 'FRAME', 'GRACE', 'HOUSE', 'IMAGE', 'JUICE', 'KNIFE', 'LIGHT', 'MAGIC', 'NIGHT', 'OCEAN', 'PEACE', 'QUICK', 'RIVER', 'SMILE', 'TOWER'],
                animals: ['CAMEL', 'EAGLE', 'HORSE', 'LLAMA', 'MOUSE', 'OTTER', 'PANDA', 'QUAIL', 'SHARK', 'TIGER'],
                colors: ['AMBER', 'CORAL', 'IVORY', 'KHAKI', 'LILAC', 'MAUVE', 'OCHRE', 'PEARL', 'ROUGE', 'SEPIA'],
                food: ['BREAD', 'CHEESE', 'GRAPE', 'HONEY', 'LEMON', 'MANGO', 'OLIVE', 'PEACH', 'SALAD', 'WHEAT'],
                nature: ['BEACH', 'CORAL', 'DELTA', 'FJORD', 'GLADE', 'MARSH', 'OASIS', 'PLAIN', 'RIDGE', 'SHORE'],
                science: ['CARBON', 'DELTA', 'FIELD', 'GRAPH', 'LOGIC', 'ORBIT', 'PHASE', 'SCALE', 'THEORY', 'VIRUS'],
                sports: ['ARENA', 'COACH', 'FIELD', 'MATCH', 'PITCH', 'SCORE', 'SPORT', 'TRACK', 'VAULT', 'YOUTH']
            },
            hard: {
                general: ['BRIDGE', 'CORNER', 'FINGER', 'GLOBAL', 'HEALTH', 'ISLAND', 'JACKET', 'KIDNEY', 'LISTEN', 'MIRROR', 'NATURE', 'ORANGE', 'POLISH', 'QUARRY', 'RACING', 'SCREEN'],
                animals: ['BEETLE', 'FALCON', 'GIRAFFE', 'IGUANA', 'JAGUAR', 'LIZARD', 'MONKEY', 'PYTHON', 'RABBIT', 'SPIDER'],
                colors: ['BEIGE', 'BRONZE', 'COBALT', 'GOLDEN', 'INDIGO', 'MAROON', 'PURPLE', 'SALMON', 'SILVER', 'VIOLET'],
                food: ['BASIL', 'CARROT', 'GARLIC', 'KIWI', 'LENTIL', 'MUSHROOM', 'PEPPER', 'QUINOA', 'TOMATO', 'WALNUT'],
                nature: ['CANYON', 'FOREST', 'GLACIER', 'JUNGLE', 'MEADOW', 'PRAIRIE', 'RAVINE', 'SAVANNA', 'TUNDRA', 'VALLEY'],
                science: ['ENERGY', 'FOSSIL', 'GENOME', 'ISOTOPE', 'MATRIX', 'OXYGEN', 'PLASMA', 'QUASAR', 'SERUM', 'VECTOR'],
                sports: ['BOXING', 'DIVING', 'HOCKEY', 'KARATE', 'RACING', 'RUGBY', 'SKIING', 'TENNIS', 'VOLLEY', 'WEIGHT']
            },
            expert: {
                general: ['BALANCE', 'CLIMATE', 'DIGNITY', 'ECLIPSE', 'FANTASY', 'GALLERY', 'HARMONY', 'INSIGHT', 'JOURNEY', 'KITCHEN', 'LIBERTY', 'MEETING', 'NETWORK', 'OPINION', 'PROJECT'],
                animals: ['BUFFALO', 'CHEETAH', 'DOLPHIN', 'ELEPHANT', 'FLAMINGO', 'HAMSTER', 'LEOPARD', 'OCTOPUS', 'PENGUIN', 'RACCOON'],
                colors: ['CRIMSON', 'EMERALD', 'FUCHSIA', 'MAGENTA', 'SCARLET', 'TURQUOISE', 'VERMILLION', 'CHARTREUSE', 'BURGUNDY', 'LAVENDER'],
                food: ['AVOCADO', 'BROCCOLI', 'COCONUT', 'EGGPLANT', 'GRAPEFRUIT', 'LETTUCE', 'NECTARINE', 'PINEAPPLE', 'SPINACH', 'ZUCCHINI'],
                nature: ['BAMBOO', 'CASCADE', 'EVERGREEN', 'HABITAT', 'LANDSCAPE', 'MONSOON', 'PLATEAU', 'RAINFOREST', 'SUNRISE', 'WATERFALL'],
                science: ['BIOLOGY', 'CHEMISTRY', 'ELECTRON', 'FORMULA', 'GRAVITY', 'HYDROGEN', 'MOLECULE', 'NEUTRON', 'PARTICLE', 'QUANTUM'],
                sports: ['ARCHERY', 'BOWLING', 'CYCLING', 'FENCING', 'GYMNASTICS', 'JAVELIN', 'MARATHON', 'SAILING', 'SURFING', 'WRESTLING']
            }
        };

        // Word hints database
        const wordHints = {
            // Easy hints
            'BOOK': 'Something you read',
            'CAKE': 'Sweet birthday treat',
            'DOOR': 'Entrance to a room',
            'FISH': 'Swims in water',
            'BEAR': 'Large forest animal',
            'BLUE': 'Color of the sky',
            'BEEF': 'Type of meat',
            'BARK': 'Sound a dog makes',
            'BALL': 'Round sports object',
            
            // Medium hints
            'APPLE': 'Red or green fruit',
            'CHAIR': 'Furniture to sit on',
            'EAGLE': 'Large bird of prey',
            'HOUSE': 'Place where you live',
            'TIGER': 'Striped big cat',
            'BREAD': 'Baked food staple',
            'BEACH': 'Sandy shore by water',
            'FIELD': 'Open area of land',
            
            // Hard hints
            'BRIDGE': 'Structure over water',
            'FINGER': 'Part of your hand',
            'ISLAND': 'Land surrounded by water',
            'BEETLE': 'Insect with hard shell',
            'BRONZE': 'Metallic color',
            'CANYON': 'Deep valley with steep sides',
            'ENERGY': 'Power to do work',
            'BOXING': 'Fighting sport with gloves',
            
            // Expert hints
            'BALANCE': 'State of equilibrium',
            'ECLIPSE': 'When one celestial body blocks another',
            'BUFFALO': 'Large American mammal',
            'CRIMSON': 'Deep red color',
            'AVOCADO': 'Green pear-shaped fruit',
            'BAMBOO': 'Fast-growing plant',
            'BIOLOGY': 'Study of living things',
            'ARCHERY': 'Sport using bow and arrows'
        };

        function setupWordGuess() {
            wordScore = 0;
            wordStreak = 0;
            currentTargetWord = '';
            currentGuess = '';
            currentRow = 0;
            wordGameOver = false;
            wordGrid = [];

            currentWordCategory = 'general';
            currentWordDifficulty = 'medium';
            currentWordLength = 5;
            
            createWordGrid();
            createWordKeyboard();
            newWordGame();
        }

        function createWordGrid() {
            const grid = document.getElementById('word-grid');
            grid.innerHTML = '';
            grid.className = 'grid grid-cols-5 gap-2 max-w-xs mx-auto';
            
            wordGrid = [];
            for (let row = 0; row < 6; row++) {
                wordGrid[row] = [];
                for (let col = 0; col < 5; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'w-12 h-12 border-2 border-gray-300 rounded flex items-center justify-center text-lg font-bold';
                    cell.id = `word-cell-${row}-${col}`;
                    grid.appendChild(cell);
                    wordGrid[row][col] = { letter: '', status: '' };
                }
            }
        }

        function createWordKeyboard() {
            const keyboard = document.getElementById('word-keyboard');
            keyboard.innerHTML = '';
            
            const rows = [
                ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
                ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
                ['ENTER', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', 'BACK']
            ];
            
            rows.forEach(row => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'flex justify-center gap-1 mb-2';
                
                row.forEach(key => {
                    const btn = document.createElement('button');
                    btn.className = `px-3 py-4 text-sm font-bold rounded transition-colors ${
                        key === 'ENTER' || key === 'BACK' 
                            ? 'bg-gray-500 text-white px-4' 
                            : 'bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500'
                    }`;
                    btn.textContent = key === 'BACK' ? '‚å´' : key;
                    btn.onclick = () => handleKeyPress(key);
                    btn.id = `key-${key}`;
                    rowDiv.appendChild(btn);
                });
                
                keyboard.appendChild(rowDiv);
            });
        }

        function getWordList() {
            const difficulty = currentWordDifficulty || 'medium';
            const category = currentWordCategory || 'general';
            
            // Update word length and max rows based on difficulty
            switch (difficulty) {
                case 'easy':
                    currentWordLength = 4;
                    maxRows = 7;
                    break;
                case 'medium':
                    currentWordLength = 5;
                    maxRows = 6;
                    break;
                case 'hard':
                    currentWordLength = 6;
                    maxRows = 5;
                    break;
                case 'expert':
                    currentWordLength = 7;
                    maxRows = 4;
                    break;
            }
            
            return wordDatabases[difficulty][category] || wordDatabases.medium.general;
        }

        function newWordGame() {
            // Get word list based on difficulty and category
            const wordList = getWordList();
            currentTargetWord = wordList[Math.floor(Math.random() * wordList.length)];
            currentGuess = '';
            currentRow = 0;
            wordGameOver = false;
            hintsUsed = 0;
            
            // Recreate grid with correct dimensions
            createWordGrid();
            
            // Reset keyboard colors
            document.querySelectorAll('[id^="key-"]').forEach(key => {
                if (!key.id.includes('ENTER') && !key.id.includes('BACK')) {
                    key.className = 'px-3 py-4 text-sm font-bold rounded transition-colors bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500';
                }
            });
            
            // Reset keyboard colors
            document.querySelectorAll('[id^="key-"]').forEach(key => {
                if (!key.id.includes('ENTER') && !key.id.includes('BACK')) {
                    key.className = 'px-3 py-4 text-sm font-bold rounded transition-colors bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500';
                }
            });
            
            updateWordDisplay();
            document.getElementById('word-result').textContent = '';
            document.getElementById('word-hint').textContent = '';
        }

        function setWordDifficulty(difficulty) {
            currentWordDifficulty = difficulty;
            
            // Update button appearance
            document.querySelectorAll('.word-difficulty-btn').forEach(btn => {
                btn.classList.remove('ring-2', 'ring-white');
            });
            event.target.classList.add('ring-2', 'ring-white');
            
            // Update current difficulty display
            const difficultyNames = {
                'easy': 'Easy',
                'medium': 'Medium', 
                'hard': 'Hard',
                'expert': 'Expert'
            };
            document.getElementById('current-word-difficulty').textContent = difficultyNames[difficulty];
            
            // Update category dropdown based on difficulty
            currentWordCategory = document.getElementById('word-category').value;
            document.getElementById('current-word-category').textContent = 
                document.getElementById('word-category').selectedOptions[0].textContent;
        }

        function giveWordHint() {
            if (hintsUsed >= 3 || wordGameOver) return;
            
            hintsUsed++;
            wordScore = Math.max(0, wordScore - 5);
            
            const hint = wordHints[currentTargetWord] || 'No hint available for this word';
            document.getElementById('word-hint').textContent = `Hint ${hintsUsed}/3: ${hint}`;
            updateWordDisplay();
        }

        // Update category selection
        document.addEventListener('DOMContentLoaded', () => {
            const categorySelect = document.getElementById('word-category');
            if (categorySelect) {
                categorySelect.addEventListener('change', function() {
                    currentWordCategory = this.value;
                    document.getElementById('current-word-category').textContent = 
                        this.selectedOptions[0].textContent;
                });
            }
        });

        function handleKeyPress(key) {
            if (wordGameOver) return;
            
            if (key === 'ENTER') {
                if (currentGuess.length === 5) {
                    submitGuess();
                }
            } else if (key === 'BACK') {
                if (currentGuess.length > 0) {
                    currentGuess = currentGuess.slice(0, -1);
                    updateCurrentRow();
                }
            } else if (currentGuess.length < 5) {
                currentGuess += key;
                updateCurrentRow();
            }
        }

        function updateCurrentRow() {
            for (let col = 0; col < 5; col++) {
                const cell = document.getElementById(`word-cell-${currentRow}-${col}`);
                if (col < currentGuess.length) {
                    cell.textContent = currentGuess[col];
                    cell.className = 'w-12 h-12 border-2 border-gray-400 rounded flex items-center justify-center text-lg font-bold bg-white dark:bg-gray-700';
                } else {
                    cell.textContent = '';
                    cell.className = 'w-12 h-12 border-2 border-gray-300 rounded flex items-center justify-center text-lg font-bold';
                }
            }
        }

        function submitGuess() {
            // Check each letter and assign colors
            const letterCounts = {};
            for (let letter of currentTargetWord) {
                letterCounts[letter] = (letterCounts[letter] || 0) + 1;
            }
            
            const guessResult = [];
            
            // First pass: mark exact matches
            for (let i = 0; i < 5; i++) {
                if (currentGuess[i] === currentTargetWord[i]) {
                    guessResult[i] = 'correct';
                    letterCounts[currentGuess[i]]--;
                } else {
                    guessResult[i] = 'pending';
                }
            }
            
            // Second pass: mark partial matches
            for (let i = 0; i < 5; i++) {
                if (guessResult[i] === 'pending') {
                    if (letterCounts[currentGuess[i]] > 0) {
                        guessResult[i] = 'partial';
                        letterCounts[currentGuess[i]]--;
                    } else {
                        guessResult[i] = 'wrong';
                    }
                }
            }
            
            // Update grid colors
            for (let col = 0; col < 5; col++) {
                const cell = document.getElementById(`word-cell-${currentRow}-${col}`);
                const letter = currentGuess[col];
                const status = guessResult[col];
                
                wordGrid[currentRow][col] = { letter, status };
                
                if (status === 'correct') {
                    cell.className = 'w-12 h-12 border-2 border-green-500 bg-green-500 text-white rounded flex items-center justify-center text-lg font-bold';
                } else if (status === 'partial') {
                    cell.className = 'w-12 h-12 border-2 border-yellow-500 bg-yellow-500 text-white rounded flex items-center justify-center text-lg font-bold';
                } else {
                    cell.className = 'w-12 h-12 border-2 border-gray-500 bg-gray-500 text-white rounded flex items-center justify-center text-lg font-bold';
                }
                
                // Update keyboard colors
                const keyBtn = document.getElementById(`key-${letter}`);
                if (keyBtn) {
                    if (status === 'correct') {
                        keyBtn.className = 'px-3 py-4 text-sm font-bold rounded transition-colors bg-green-500 text-white';
                    } else if (status === 'partial' && !keyBtn.className.includes('bg-green-500')) {
                        keyBtn.className = 'px-3 py-4 text-sm font-bold rounded transition-colors bg-yellow-500 text-white';
                    } else if (status === 'wrong' && !keyBtn.className.includes('bg-green-500') && !keyBtn.className.includes('bg-yellow-500')) {
                        keyBtn.className = 'px-3 py-4 text-sm font-bold rounded transition-colors bg-gray-500 text-white';
                    }
                }
            }
            
            // Check win/lose conditions
            if (currentGuess === currentTargetWord) {
                wordScore += (6 - currentRow) * 10; // More points for fewer guesses
                wordStreak++;
                wordGameOver = true;
                document.getElementById('word-result').textContent = `üéâ Correct! The word was ${currentTargetWord}`;
                document.getElementById('word-result').style.color = '#16a34a';
            } else if (currentRow === 5) {
                wordStreak = 0;
                wordGameOver = true;
                document.getElementById('word-result').textContent = `üòû Game Over! The word was ${currentTargetWord}`;
                document.getElementById('word-result').style.color = '#dc2626';
            }
            
            currentRow++;
            currentGuess = '';
            updateWordDisplay();
        }

        function updateWordDisplay() {
            document.getElementById('word-score').textContent = wordScore;
            document.getElementById('word-streak').textContent = wordStreak;
        }

        function resetWordGuess() {
            wordScore = 0;
            wordStreak = 0;
            updateWordDisplay();
            newWordGame();
        }

        // Handle physical keyboard input
        document.addEventListener('keydown', (e) => {
            if (currentGame !== 'word-guess') return;
            
            const key = e.key.toUpperCase();
            if (key >= 'A' && key <= 'Z') {
                handleKeyPress(key);
            } else if (key === 'ENTER') {
                handleKeyPress('ENTER');
            } else if (key === 'BACKSPACE') {
                handleKeyPress('BACK');
            }
        });

        function showComingSoon(gameName, description) {
            // Find the current game page and add coming soon content
            const pageId = currentGame + '-page';
            const page = document.getElementById(pageId);
            
            if (page) {
                // Check if it already has content
                const existingContent = page.querySelector('.coming-soon-content');
                if (!existingContent) {
                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'coming-soon-content text-center mt-8';
                    contentDiv.innerHTML = `
                        <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-8 max-w-md mx-auto">
                            <div class="text-6xl mb-4">üöß</div>
                            <h3 class="text-2xl font-bold mb-4">Coming Soon!</h3>
                            <p class="text-gray-600 dark:text-gray-400 mb-4">${description}</p>
                            <p class="text-sm text-gray-500">This game is currently under development.</p>
                        </div>
                    `;
                    page.appendChild(contentDiv);
                }
            }
        }

        // Initialize the app
        document.addEventListener('DOMContentLoaded', () => {
            showPage('home');
        });
    </script>
</body>
</html>
